		Session.vim	/^nnoremap <buffer> 	 :call search('\\[[0-9]*:[^\\]]*\\]')$/;"	m
	Session.vim	/^nnoremap <buffer>  :WinManagerGotoNextInGroup "FileExplorer"$/;"	m
	Session.vim	/^nnoremap <buffer>  :WinManagerGotoNextInGroup "TagList"$/;"	m
	Session.vim	/^nnoremap <buffer>  :WinManagerGotoPrevInGroup "FileExplorer"$/;"	m
	Session.vim	/^nnoremap <buffer>  :WinManagerGotoPrevInGroup "TagList"$/;"	m
	Session.vim	/^nmap  :BottomExplorerWindow$/;"	m
	Session.vim	/^nmap  :FirstExplorerWindow$/;"	m
	Session.vim	/^nnoremap <buffer>  <Nop>$/;"	m
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
*	Session.vim	/^inoremap <buffer> <silent> * :silent! %foldopen!$/;"	m
*	Session.vim	/^nnoremap <buffer> <silent> * :silent! %foldopen!$/;"	m
+	Session.vim	/^inoremap <buffer> <silent> + :silent! foldopen$/;"	m
+	Session.vim	/^nnoremap <buffer> <silent> + :silent! foldopen$/;"	m
-	Session.vim	/^inoremap <buffer> <silent> - :silent! foldclose$/;"	m
-	Session.vim	/^nnoremap <buffer> <silent> - :silent! foldclose$/;"	m
0	Session.vim	/^normal! 0$/;"	m
095|	Session.vim	/^normal! 095|$/;"	m
<Down>	Session.vim	/^nnoremap <buffer> <Down> gj$/;"	m
<F4>	Session.vim	/^map <F4> :WMToggle$/;"	m
<Plug>NetrwBrowseX	Session.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())$/;"	m
<Plug>NetrwBrowseXVis	Session.vim	/^vnoremap <silent> <Plug>NetrwBrowseXVis :call netrw#BrowseXVis()$/;"	m
<S-Tab>	Session.vim	/^nnoremap <buffer> <S-Tab> :call search('\\[[0-9]*:[^\\]]*\\]','b')$/;"	m
<Up>	Session.vim	/^nnoremap <buffer> <Up> gk$/;"	m
<kMinus>	Session.vim	/^inoremap <buffer> <silent> <kMinus> :silent! foldclose$/;"	m
<kMinus>	Session.vim	/^nnoremap <buffer> <silent> <kMinus> :silent! foldclose$/;"	m
<kMultiply>	Session.vim	/^inoremap <buffer> <silent> <kMultiply> :silent! %foldopen!$/;"	m
<kMultiply>	Session.vim	/^nnoremap <buffer> <silent> <kMultiply> :silent! %foldopen!$/;"	m
<kPlus>	Session.vim	/^inoremap <buffer> <silent> <kPlus> :silent! foldopen$/;"	m
<kPlus>	Session.vim	/^nnoremap <buffer> <silent> <kPlus> :silent! foldopen$/;"	m
=	Session.vim	/^inoremap <buffer> <silent> = :silent! %foldclose$/;"	m
=	Session.vim	/^nnoremap <buffer> <silent> = :silent! %foldclose$/;"	m
ACTIVE_ADJUST	initialize.c	29;"	d	file:
ACTIVE_FIXED	initialize.c	28;"	d	file:
AD_COPYBACK	initialize.h	43;"	d
AD_INTERLEAVE	initialize.h	45;"	d
AD_RANDOM	initialize.h	42;"	d
AD_TWOPLANE	initialize.h	44;"	d
AD_TWOPLANE_READ	initialize.h	46;"	d
AVLTREE_H	avlTree.h	2;"	d
AVL_NULL	avlTree.h	8;"	d
AVL_TREENODE_FREE	avlTree.c	/^void AVL_TREENODE_FREE$/;"	f
AVL_TREE_LOCK	avlTree.c	/^void AVL_TREE_LOCK$/;"	f
AVL_TREE_UNLOCK	avlTree.c	/^void AVL_TREE_UNLOCK$/;"	f
BDBM_DFTL_PAGE_STATUS	initialize.h	/^enum BDBM_DFTL_PAGE_STATUS{$/;"	g
BLOKC	initialize.h	121;"	d
BUFSIZE	initialize.h	30;"	d
CHANNEL	initialize.h	117;"	d
CHANNEL_C_A_TRANSFER	initialize.h	69;"	d
CHANNEL_DATA_TRANSFER	initialize.h	75;"	d
CHANNEL_GC	initialize.h	70;"	d
CHANNEL_GC_ERASE	initialize.h	72;"	d
CHANNEL_IDLE	initialize.h	68;"	d
CHANNEL_TRANSFER	initialize.h	76;"	d
CHANNEL_UNKNOWN	initialize.h	77;"	d
CHIP_COPYBACK_BUSY	initialize.h	90;"	d
CHIP_C_A_TRANSFER	initialize.h	82;"	d
CHIP_DATA_TRANSFER	initialize.h	87;"	d
CHIP_ERASE_BUSY	initialize.h	89;"	d
CHIP_GC_RW_BUSY	initialize.h	85;"	d
CHIP_IDLE	initialize.h	79;"	d
CHIP_READ_BUSY	initialize.h	81;"	d
CHIP_WAIT	initialize.h	88;"	d
CHIP_WRITE_BUSY	initialize.h	80;"	d
CHIP_WRITE_DATA_CMD_BUSY	initialize.h	84;"	d
CHUNKSIZE	diffXmatch.h	3;"	d
COMPLETE_MATCHED	xmatchPro.h	11;"	d
COMPRESSION_COST_TIME_ONE_PAGE	ssd.h	34;"	d
COMPRESSION_DFTL_deal_in_distributing_subrequests	ssd.c	/^struct ssd_info* COMPRESSION_DFTL_deal_in_distributing_subrequests(struct ssd_info* ssd)$/;"	f
COMPRESSION_read_value_request_DFTL_parameters	ssd.c	/^void COMPRESSION_read_value_request_DFTL_parameters(struct ssd_info* ssd, struct request* req)$/;"	f
COMPRESSION_write_value_request_DFTL_parameters	ssd.c	/^void COMPRESSION_write_value_request_DFTL_parameters(struct ssd_info* ssd, struct request* req)$/;"	f
COMP_PAGE_NUMBER_ONCE	ssd.h	40;"	d
COMP_VS_UNCOMP_IN_DFTL_BUFFER	ssd.h	39;"	d
CONFIG_BUFFER_MONITOR_COMPRESSION_TRANS	debug.h	11;"	d
CONFIG_BUFFER_MONITOR_ENTRY	debug.h	9;"	d
CONFIG_BUFFER_MONITOR_TRANS	debug.h	10;"	d
CONFIG_ENABLE_MSG	debug.h	18;"	d
CONFIG_TRACE_READ_PROCESS	debug.h	8;"	d
CONFIG_TRACE_WRITE_PROCESS	debug.h	7;"	d
CONFIG_WRONG_PROCESS_DEBUG_ENABLE_MSG	debug.h	19;"	d
COPY_BACK	initialize.h	40;"	d
DFTL	ssd.h	35;"	d
DFTL_DIR_CLEAN	initialize.h	/^    DFTL_DIR_CLEAN = DFTL_DIR_DRAM | 0x1,$/;"	e	enum:__anon1
DFTL_DIR_DIRTY	initialize.h	/^    DFTL_DIR_DIRTY = DFTL_DIR_DRAM | 0x2,$/;"	e	enum:__anon1
DFTL_DIR_DRAM	initialize.h	/^    DFTL_DIR_DRAM = 0x200,$/;"	e	enum:__anon1
DFTL_DIR_EMPTY	initialize.h	/^    DFTL_DIR_EMPTY = 0,$/;"	e	enum:__anon1
DFTL_DIR_FLASH	initialize.h	/^    DFTL_DIR_FLASH = 0x100,$/;"	e	enum:__anon1
DFTL_PAGE_INVALID	initialize.h	/^        DFTL_PAGE_INVALID,$/;"	e	enum:BDBM_DFTL_PAGE_STATUS
DFTL_PAGE_INVALID_ADDR	initialize.h	/^        DFTL_PAGE_INVALID_ADDR = -1, $/;"	e	enum:BDBM_DFTL_PAGE_STATUS
DFTL_PAGE_NOT_EXIST	initialize.h	/^    DFTL_PAGE_NOT_EXIST = 0,$/;"	e	enum:BDBM_DFTL_PAGE_STATUS
DFTL_PAGE_NOT_MAPPED	initialize.h	/^    DFTL_PAGE_NOT_MAPPED,$/;"	e	enum:BDBM_DFTL_PAGE_STATUS
DFTL_PAGE_VALID	initialize.h	/^        DFTL_PAGE_VALID,$/;"	e	enum:BDBM_DFTL_PAGE_STATUS
DFTL_buffer_management	ssd.c	/^struct ssd_info *DFTL_buffer_management(struct ssd_info *ssd) $/;"	f
DFTL_deal_in_distributing_subrequests	ssd.c	/^struct ssd_info* DFTL_deal_in_distributing_subrequests(struct ssd_info* ssd)$/;"	f
DICTIONARY	dictionary.h	9;"	d
DICTIONARY_SIZE	dictionary.h	6;"	d
DIC_ENTRY	dictionary.h	10;"	d
DYNAMIC_ALLOCATION	initialize.h	32;"	d
Dram_write_map	initialize.h	/^typedef struct Dram_write_map {$/;"	s
Dram_write_map	initialize.h	/^} Dram_write_map;$/;"	t	typeref:struct:Dram_write_map
EH_FACTOR	avlTree.h	10;"	d
ERROR	initialize.h	135;"	d
FAILURE	initialize.h	134;"	d
FALSE	initialize.c	25;"	d	file:
FALSE	initialize.h	132;"	d
FLASH_H	flash.h	20;"	d
GC_COMPLETE	initialize.h	113;"	d
GC_COPY_BACK	initialize.h	112;"	d
GC_ERASE_C_A	initialize.h	111;"	d
GC_INTERRUPT	initialize.h	114;"	d
GC_UNINTERRUPT	initialize.h	115;"	d
GC_WAIT	initialize.h	110;"	d
HEADER_LENGTH	xmatchPro.h	9;"	d
INFEASIBLE	initialize.h	136;"	d
INITIALIZE_H	initialize.h	19;"	d
INSERT_NEXT	avlTree.h	20;"	d
INSERT_PREV	avlTree.h	19;"	d
INTERLEAVE	initialize.h	35;"	d
INTERLEAVE_TWO_PLANE	initialize.h	39;"	d
If_hitInBUffer_move_theNode_ahead_in_readrequest	ssd.c	/^void If_hitInBUffer_move_theNode_ahead_in_readrequest(struct ssd_info* ssd, struct buffer_info* buffer, struct buffer_group* buffer_node)$/;"	f
If_hitInBUffer_move_theNode_ahead_in_writerequest	ssd.c	/^void If_hitInBUffer_move_theNode_ahead_in_writerequest(struct ssd_info* ssd,struct buffer_info* buffer, struct buffer_group* buffer_node)$/;"	f
LEFT_MINUS	avlTree.h	13;"	d
LH_FACTOR	avlTree.h	11;"	d
LOG_DICTIONARY_SIZE	dictionary.h	7;"	d
LRU_link_next	initialize.h	/^    struct buffer_group *LRU_link_next;    \/\/ next node in LRU list$/;"	m	struct:buffer_group	typeref:struct:buffer_group::buffer_group
LRU_link_next	initialize.h	/^    struct buffer_group *LRU_link_next;    \/\/ next node in LRU list$/;"	m	struct:buffer_group_for_DFTL	typeref:struct:buffer_group_for_DFTL::buffer_group
LRU_link_pre	initialize.h	/^    struct buffer_group *LRU_link_pre;    \/\/ previous node in LRU list$/;"	m	struct:buffer_group	typeref:struct:buffer_group::buffer_group
LRU_link_pre	initialize.h	/^    struct buffer_group *LRU_link_pre;    \/\/ previous node in LRU list$/;"	m	struct:buffer_group_for_DFTL	typeref:struct:buffer_group_for_DFTL::buffer_group
L_Rotate	avlTree.c	/^static void L_Rotate(TREE_NODE **ppNode) {$/;"	f	file:
LeftBalance	avlTree.c	/^static void LeftBalance(TREE_NODE **ppNode) {$/;"	f	file:
MAPPINGTABLE_READ	initialize.h	51;"	d
MAPPINGTABLE_WRITE	initialize.h	52;"	d
MAPPING_ENTRY_SIZE	initialize.c	30;"	d	file:
MASK	xmatchPro.c	383;"	d	file:
MATCHED_HEADER	xmatchPro.h	14;"	d
MATCHE_TYPE_LENGTH	xmatchPro.h	18;"	d
MAX_CACHED_DIR_SLOTS_SIZE	initialize.h	58;"	d
MAX_CACHED_ENTRIES_SIZE	initialize.h	59;"	d
MAX_INT64	pagemap.h	24;"	d
MAX_INT64	ssd.h	42;"	d
NORMAL	initialize.h	38;"	d
NUMBER_OF_WRITE_ITERATION	flash.c	21;"	d	file:
NUM_BITS_PER_TOKEN	xmatchPro.h	19;"	d
NUM_BYTES_PER_TOKEN	xmatchPro.h	17;"	d
NUM_ENTRIES_PER_DIR	initialize.h	57;"	d
ORDER_LIST_WANTED	avlTree.h	17;"	d
OUTPUT	initialize.h	108;"	d
OVERFLOW	initialize.h	137;"	d
PAGE	initialize.h	122;"	d
PAGEMAP_H	pagemap.h	19;"	d
PG_SUB	initialize.h	125;"	d
PLANE	initialize.h	120;"	d
Pop_DFTL_buffer	ssd.c	/^int Pop_DFTL_buffer(struct ssd_info* ssd, struct request* req)$/;"	f
READ	initialize.h	48;"	d
REQUEST_IN	initialize.h	107;"	d
RH_FACTOR	avlTree.h	12;"	d
RIGHT_MINUS	avlTree.h	14;"	d
R_Rotate	avlTree.c	/^static void R_Rotate(TREE_NODE **ppNode) {$/;"	f	file:
RightBalance	avlTree.c	/^static void RightBalance(TREE_NODE **ppNode) {$/;"	f	file:
SECTOR	initialize.h	29;"	d
SET_INTO_LIMITTED_BUFFER	ssd.h	41;"	d
SR_COMPLETE	initialize.h	105;"	d
SR_R_C_A_TRANSFER	initialize.h	94;"	d
SR_R_DATA_TRANSFER	initialize.h	96;"	d
SR_R_READ	initialize.h	95;"	d
SR_WAIT	initialize.h	93;"	d
SR_W_C_A_DATA_TRANSFER	initialize.h	97;"	d
SR_W_DATA_TRANSFER	initialize.h	103;"	d
SR_W_DATA_TRANSFER_ONE_PROG_OF_ITERATIONS	initialize.h	98;"	d
SR_W_DATA_TRANSFER_ONE_VERIFY_OF_ITERATIONS	initialize.h	99;"	d
SR_W_TRANSFER	initialize.h	100;"	d
STATIC_ALLOCATION	initialize.h	33;"	d
SUBPAGE	initialize.h	123;"	d
SUCCESS	initialize.h	133;"	d
SessionLoad	Session.vim	/^let SessionLoad = 1$/;"	v
Status	initialize.h	/^typedef int Status;$/;"	t
TRANSLATION_PAGE_UNIT	ssd.h	38;"	d
TREE_NODE	avlTree.h	/^} TREE_NODE;$/;"	t	typeref:struct:_AVL_TREE_NODE
TRUE	initialize.c	26;"	d	file:
TRUE	initialize.h	131;"	d
TWO_PLANE	initialize.h	36;"	d
TYPE	js_list.h	4;"	d
UNKNOWN	initialize.h	91;"	d
UNMATCHED	xmatchPro.h	12;"	d
UNMATCHED_HEADER	xmatchPro.h	15;"	d
WRITE	initialize.h	49;"	d
WRITE_RATIO_IN_REQUEST_QUEUE	ssd.c	19;"	d	file:
\mbc	Session.vim	/^map \\mbc <Plug>CMiniBufExplorer$/;"	m
\mbe	Session.vim	/^map \\mbe <Plug>MiniBufExplorer$/;"	m
\mbt	Session.vim	/^map \\mbt <Plug>TMiniBufExplorer$/;"	m
\mbu	Session.vim	/^map \\mbu <Plug>UMiniBufExplorer$/;"	m
_AVL_TREE_NODE	avlTree.h	/^typedef struct _AVL_TREE_NODE {$/;"	s
_BI_LIST_H	bi_list.h	2;"	d
_CRTDBG_MAP_ALLOC	initialize.c	19;"	d	file:
_CRTDBG_MAP_ALLOC	pagemap.c	19;"	d	file:
_DICTIONARY_H	dictionary.h	2;"	d
_DIFFXMATCH_C	diffXmatch.c	2;"	d	file:
_JS_LIST_H	js_list.h	2;"	d
_SSDSIM_DEBUG_H	debug.h	2;"	d
_XMATCHPRO_H_	xmatchPro.h	2;"	d
_bi_list	bi_list.h	/^typedef struct _bi_list{$/;"	s
_bi_node	bi_list.h	/^typedef struct _bi_node {$/;"	s
ac_time_characteristics	initialize.h	/^struct ac_time_characteristics {$/;"	s
ac_timing	initialize.h	/^    struct ac_time_characteristics ac_timing;$/;"	m	struct:chip_info	typeref:struct:chip_info::ac_time_characteristics
ac_timing	initialize.h	/^} ac_timing;$/;"	v	typeref:struct:ac_time_characteristics
active_block	initialize.h	/^    unsigned int active_block;          \/\/if a die has a active block, è¯¥é¡¹è¡¨ç¤ºå…¶ç‰©ç†å—å·$/;"	m	struct:plane_info
active_current	initialize.h	/^    float active_current;$/;"	m	struct:dram_parameter
active_flag	initialize.h	/^    int active_flag;                     \/\/è®°å½•ä¸»åŠ¨å†™æ˜¯å¦é˜»å¡ï¼Œå¦‚æœå‘ç°æŸ±å¡ï¼Œéœ€è¦å°†æ—¶é—´å‘å‰æ¨è¿›,0è¡¨ç¤ºæ²¡æœ‰é˜»å¡ï¼Œ1è¡¨ç¤ºè¢«é˜»å¡ï¼Œéœ€è¦å‘å‰æ¨è¿›æ—¶é—´$/;"	m	struct:ssd_info
active_write	initialize.h	/^    int active_write;               \/\/è¡¨ç¤ºæ˜¯å¦æ‰§è¡Œä¸»åŠ¨å†™æ“ä½œ1,yes;0,no$/;"	m	struct:parameter_value
ad_priority	initialize.h	/^    int ad_priority;                \/\/record the priority between two plane operation and interleave operation$/;"	m	struct:parameter_value
ad_priority2	initialize.h	/^    int ad_priority2;               \/\/record the priority of channel-level, 0 indicates that the priority order of channel-level is highest; 1 indicates the contrary$/;"	m	struct:parameter_value
add_reg_ppn	initialize.h	/^    int add_reg_ppn;                    \/\/readï¼Œwriteæ—¶æŠŠåœ°å€ä¼ é€åˆ°è¯¥å˜é‡ï¼Œè¯¥å˜é‡ä»£è¡¨åœ°å€å¯„å­˜å™¨ã€‚dieç”±busyå˜ä¸ºidleæ—¶ï¼Œæ¸…é™¤åœ°å€ \/\/æœ‰å¯èƒ½å› ä¸ºä¸€å¯¹å¤šçš„æ˜ å°„ï¼Œåœ¨ä¸€ä¸ªè¯»è¯·æ±‚æ—¶ï¼Œæœ‰å¤šä¸ªç›¸åŒçš„lpnï¼Œæ‰€ä»¥éœ€è¦ç”¨ppnæ¥åŒºåˆ†$/;"	m	struct:plane_info
address_mapping	initialize.h	/^    int address_mapping;            \/\/è®°å½•æ˜ å°„çš„ç±»å‹ï¼Œ1ï¼špageï¼›2ï¼šblockï¼›3ï¼šfast$/;"	m	struct:parameter_value
advanced_commands	initialize.h	/^    int advanced_commands;$/;"	m	struct:parameter_value
after_pre_process_pages_number	initialize.h	/^int after_pre_process_pages_number;$/;"	m	struct:ssd_info
after_pre_processe_and_aged_pages_number	initialize.h	/^int after_pre_processe_and_aged_pages_number;$/;"	m	struct:ssd_info
aged	initialize.h	/^    int aged;                       \/\/1è¡¨ç¤ºéœ€è¦å°†è¿™ä¸ªSSDå˜æˆagedï¼Œ0è¡¨ç¤ºéœ€è¦å°†è¿™ä¸ªSSDä¿æŒnon-aged$/;"	m	struct:parameter_value
aged_ratio	initialize.h	/^    float aged_ratio;$/;"	m	struct:parameter_value
alloc_assert	pagemap.c	/^void alloc_assert(void *p, char *s)\/\/æ–­è¨€$/;"	f
alloc_pool	initialize.h	/^    int alloc_pool;                 \/\/allocation pool å¤§å°(planeï¼Œdieï¼Œchipï¼Œchannel),ä¹Ÿå°±æ˜¯æ‹¥æœ‰active_blockçš„å•ä½$/;"	m	struct:parameter_value
allocate_location	flash.c	/^Status allocate_location(struct ssd_info *ssd, struct sub_request *sub_req) {$/;"	f
allocation_scheme	initialize.h	/^    int allocation_scheme;          \/\/è®°å½•åˆ†é…æ–¹å¼çš„é€‰æ‹©ï¼Œ0è¡¨ç¤ºåŠ¨æ€åˆ†é…ï¼Œ1è¡¨ç¤ºé™æ€åˆ†é…$/;"	m	struct:parameter_value
append_on_request_compression_to_uncompression_lpn_data	ssd.c	/^int append_on_request_compression_to_uncompression_lpn_data(struct request* req, int lpn, int state)$/;"	f
append_on_request_evict_in_DFTL_buffer_lpn_data	ssd.c	/^int append_on_request_evict_in_DFTL_buffer_lpn_data(struct request* req, int lpn, int state)$/;"	f
append_on_request_missing_in_DFTL_buffer_lpn_data	ssd.c	/^int append_on_request_missing_in_DFTL_buffer_lpn_data(struct request* req, int lpn, int state)$/;"	f
append_on_request_missing_in_data_buffer_lpn_data	ssd.c	/^int append_on_request_missing_in_data_buffer_lpn_data(struct request* req, int lpn, int state)$/;"	f
arrange_the_location_by_lpn	flash.c	/^void arrange_the_location_by_lpn(struct ssd_info* ssd, struct sub_request* sub_req)$/;"	f
assign_rightvalue_for_completed_mappingrelated_subrequest	flash.c	/^void assign_rightvalue_for_completed_mappingrelated_subrequest(struct sub_request* sub)$/;"	f
attach_info	initialize.h	/^    struct buffer_info *attach_info;    \/\/ info about attach map$/;"	m	struct:map_info	typeref:struct:map_info::buffer_info
ave_read_size	initialize.h	/^    float ave_read_size;$/;"	m	struct:ssd_info
ave_write_size	initialize.h	/^    float ave_write_size;$/;"	m	struct:ssd_info
avlDelBalance	avlTree.c	/^static int avlDelBalance$/;"	f	file:
avlTreeAdd	avlTree.c	/^int avlTreeAdd$/;"	f
avlTreeCheck	avlTree.c	/^int avlTreeCheck(tAVLTree *pTree, TREE_NODE *pNode) {$/;"	f
avlTreeCount	avlTree.c	/^unsigned int avlTreeCount$/;"	f
avlTreeCreate	avlTree.c	/^tAVLTree *avlTreeCreate(int *keyCompareFunc, int *freeFunc) {$/;"	f
avlTreeDel	avlTree.c	/^int avlTreeDel(tAVLTree *pTree, TREE_NODE *pDelNode) {$/;"	f
avlTreeDestroy	avlTree.c	/^int avlTreeDestroy$/;"	f
avlTreeFind	avlTree.c	/^TREE_NODE *avlTreeFind$/;"	f
avlTreeFirst	avlTree.c	/^TREE_NODE *avlTreeFirst$/;"	f
avlTreeFlush	avlTree.c	/^int avlTreeFlush$/;"	f
avlTreeHigh	avlTree.c	/^int avlTreeHigh(TREE_NODE *pNode) {$/;"	f
avlTreeInsert	avlTree.c	/^static int avlTreeInsert$/;"	f	file:
avlTreeLast	avlTree.c	/^TREE_NODE *avlTreeLast$/;"	f
avlTreeLookup	avlTree.c	/^static TREE_NODE *avlTreeLookup$/;"	f	file:
avlTreeNext	avlTree.c	/^TREE_NODE *avlTreeNext$/;"	f
avlTreePrev	avlTree.c	/^TREE_NODE *avlTreePrev$/;"	f
avlTreeRemove	avlTree.c	/^static int avlTreeRemove$/;"	f	file:
begin_time	initialize.h	/^    int64_t begin_time;               \/\/å­è¯·æ±‚å¼€å§‹æ—¶é—´$/;"	m	struct:sub_request
begin_time	initialize.h	/^    int64_t begin_time;            \/\/è®°å½•ä¸€ä¸ªplaneä»€ä¹ˆæ—¶å€™å¼€å§‹gcæ“ä½œçš„$/;"	m	struct:gc_info
begin_time	initialize.h	/^    int64_t begin_time;$/;"	m	struct:request
bf	avlTree.h	/^    int bf;                                     \/*å¹³è¡¡å› å­ï¼›å½“å¹³è¡¡å› å­çš„ç»å¯¹å€¼å¤§äº æˆ–ç­‰äº2çš„æ—¶å€™å°±è¡¨ç¤ºæ ‘ä¸å¹³è¡¡(balance_factor)*\/$/;"	m	struct:_AVL_TREE_NODE
bi_list	bi_list.h	/^}bi_list;$/;"	t	typeref:struct:_bi_list
bi_node	bi_list.h	/^}bi_node;$/;"	t	typeref:struct:_bi_node
bitBuffer	xmatchPro.h	/^	unsigned int bitBuffer;$/;"	m	struct:xmatchContext
blk_head	initialize.h	/^    struct blk_info *blk_head;$/;"	m	struct:plane_info	typeref:struct:plane_info::blk_info
blk_info	initialize.h	/^struct blk_info {$/;"	s
block	initialize.h	/^    unsigned int block;           \/\/è¯¥å‚æ•°åªåœ¨å¯ä¸­æ–­çš„gcå‡½æ•°ä¸­ä½¿ç”¨ï¼ˆgc_interruptï¼‰ï¼Œç”¨æ¥è®°å½•å·²è¿‘æ‰¾å‡ºæ¥çš„ç›®æ ‡å—å·$/;"	m	struct:gc_operation
block	initialize.h	/^    unsigned int block;$/;"	m	struct:direct_erase
block	initialize.h	/^    unsigned int block;$/;"	m	struct:local
block_num_plane	initialize.h	/^    unsigned int block_num_plane;       \/\/indicate how many blocks in a plane$/;"	m	struct:chip_info
block_plane	initialize.h	/^    unsigned int block_plane;$/;"	m	struct:parameter_value
buf_node	initialize.h	/^} buf_node;$/;"	t	typeref:struct:buffer_group
buf_node_for_DFTL	initialize.h	/^} buf_node_for_DFTL;$/;"	t	typeref:struct:buffer_group_for_DFTL
buffer	initialize.h	/^    struct buffer_info *buffer;$/;"	m	struct:dram_info	typeref:struct:dram_info::buffer_info
buffer_DFTL	initialize.h	/^struct buffer_info *buffer_DFTL;\/\/ tree header (tAVLTree* type) $/;"	m	struct:__anon4	typeref:struct:__anon4::buffer_info
buffer_DFTL_UNCOM	initialize.h	/^struct buffer_info *buffer_DFTL_UNCOM;\/\/ tree header (tAVLTree* type) $/;"	m	struct:__anon4	typeref:struct:__anon4::buffer_info
buffer_current_size	avlTree.h	/^    unsigned int buffer_current_size;$/;"	m	struct:buffer_info_for_DFTL
buffer_group	initialize.h	/^typedef struct buffer_group {$/;"	s
buffer_group_for_DFTL	initialize.h	/^typedef struct buffer_group_for_DFTL {$/;"	s
buffer_head	avlTree.h	/^    struct buffer_group *buffer_head;            \/*as LRU head which is most recently used*\/$/;"	m	struct:buffer_info	typeref:struct:buffer_info::buffer_group
buffer_head	avlTree.h	/^    struct buffer_group_for_DFTL *buffer_head;            \/*as LRU head which is most recently used*\/$/;"	m	struct:buffer_info_for_DFTL	typeref:struct:buffer_info_for_DFTL::buffer_group_for_DFTL
buffer_info	avlTree.h	/^typedef struct buffer_info {$/;"	s
buffer_info_for_DFTL	avlTree.h	/^typedef struct buffer_info_for_DFTL {$/;"	s
buffer_management	initialize.h	/^    int buffer_management;          \/\/indicates that there are buffer management or not$/;"	m	struct:parameter_value
buffer_management	ssd.c	/^struct ssd_info *buffer_management(struct ssd_info *ssd) {$/;"	f
buffer_sector_count	avlTree.h	/^    unsigned int buffer_sector_count;$/;"	m	struct:buffer_info
buffer_tail	avlTree.h	/^    struct buffer_group *buffer_tail;            \/*as LRU tail which is least recently used*\/$/;"	m	struct:buffer_info	typeref:struct:buffer_info::buffer_group
buffer_tail	avlTree.h	/^    struct buffer_group_for_DFTL *buffer_tail;            \/*as LRU tail which is least recently used*\/$/;"	m	struct:buffer_info_for_DFTL	typeref:struct:buffer_info_for_DFTL::buffer_group_for_DFTL
c	Session.vim	/^nnoremap <buffer> c :exec "cd ".b:completePathEsc$/;"	m
calc_req_slack_time	ssd.c	/^int calc_req_slack_time(struct request * req)$/;"	f
can_erase_block	initialize.h	/^    int can_erase_block;                \/\/è®°å½•åœ¨ä¸€ä¸ªplaneä¸­å‡†å¤‡åœ¨gcæ“ä½œä¸­è¢«æ“¦é™¤æ“ä½œçš„å—,-1è¡¨ç¤ºè¿˜æ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„å—$/;"	m	struct:plane_info
channel	initialize.h	/^    unsigned int channel;$/;"	m	struct:local
channel_head	initialize.h	/^    struct channel_info *channel_head;   \/\/æŒ‡å‘channelç»“æ„ä½“æ•°ç»„çš„é¦–åœ°å€$/;"	m	struct:ssd_info	typeref:struct:ssd_info::channel_info
channel_info	initialize.h	/^struct channel_info {$/;"	s
channel_number	initialize.h	/^    unsigned int channel_number;    \/\/è®°å½•SSDä¸­æœ‰å¤šå°‘ä¸ªé€šé“ï¼Œæ¯ä¸ªé€šé“æ˜¯å•ç‹¬çš„bus$/;"	m	struct:parameter_value
chip	initialize.h	/^    int chip;                            \/\/è¡¨ç¤ºåœ¨è¯¥æ€»çº¿ä¸Šæœ‰å¤šå°‘é¢—ç²’$/;"	m	struct:channel_info
chip	initialize.h	/^    unsigned int chip;$/;"	m	struct:gc_operation
chip	initialize.h	/^    unsigned int chip;$/;"	m	struct:local
chip	initialize.h	118;"	d
chip_channel	initialize.h	/^    unsigned int chip_channel[100]; \/\/è®¾ç½®SSDä¸­channelæ•°å’Œæ¯channelä¸Šé¢—ç²’çš„æ•°é‡$/;"	m	struct:parameter_value
chip_head	initialize.h	/^    struct chip_info *chip_head;$/;"	m	struct:channel_info	typeref:struct:channel_info::chip_info
chip_info	initialize.h	/^struct chip_info {$/;"	s
chip_next_predict_time_diff	initialize.h	/^        int chip_next_predict_time_diff;\/\/ recording the next predict time diff for restoring.$/;"	m	struct:gc_operation
chip_next_status	initialize.h	/^        unsigned int chip_next_status;$/;"	m	struct:gc_operation
chip_num	initialize.h	/^    unsigned int chip_num;          \/\/è®°å½•ä¸€ä¸ªSSDä¸­æœ‰å¤šå°‘ä¸ªé¢—ç²’$/;"	m	struct:parameter_value
chip_read_queue_length	initialize.h	/^int chip_read_queue_length;$/;"	m	struct:chip_info
chip_read_real_stop	initialize.h	/^unsigned int chip_read_real_stop;$/;"	m	struct:chip_info
chip_read_stop	initialize.h	/^unsigned int chip_read_stop;$/;"	m	struct:chip_info
chip_status	initialize.h	/^        unsigned int chip_status;$/;"	m	struct:gc_operation
chip_status	initialize.h	/^int chip_status;$/;"	m	struct:chip_info
chip_status_time	initialize.h	/^int chip_status_time;$/;"	m	struct:chip_info
chip_write_queue_length	initialize.h	/^int chip_write_queue_length;$/;"	m	struct:chip_info
chip_write_record_begin	initialize.h	/^unsigned int chip_write_record_begin;$/;"	m	struct:chip_info
chip_write_record_end	initialize.h	/^unsigned int chip_write_record_end;$/;"	m	struct:chip_info
clean_in_background	initialize.h	/^    int clean_in_background;        \/\/æ¸…é™¤æ“ä½œæ˜¯å¦åœ¨å‰å°å®Œæˆ$/;"	m	struct:parameter_value
clock_time	initialize.h	/^    int clock_time;$/;"	m	struct:dram_parameter
clock_time	initialize.h	/^    int64_t clock_time;                 \/\/è¡¨ç¤ºä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸçš„æ—¶é—´$/;"	m	struct:controller_info
compare	xmatchPro.c	/^int compare(unsigned int valueA, unsigned int valueB)$/;"	f
compare_DFTL_buffer_remainder_space_with_missing_in_DFTL_buffer	ssd.c	/^int compare_DFTL_buffer_remainder_space_with_missing_in_DFTL_buffer(struct ssd_info* ssd, struct request* request)$/;"	f
complete_lsn_count	initialize.h	/^    unsigned int complete_lsn_count;   \/\/record the count of lsn served by buffer$/;"	m	struct:request
complete_time	initialize.h	/^    int64_t complete_time;            \/\/è®°å½•è¯¥å­è¯·æ±‚çš„å¤„ç†æ—¶é—´,æ—¢çœŸæ­£å†™å…¥æˆ–è€…è¯»å‡ºæ•°æ®çš„æ—¶é—´$/;"	m	struct:sub_request
compression_compare_DFTL_buffer_remainder_space_with_compression_area_coming	ssd.c	/^int compression_compare_DFTL_buffer_remainder_space_with_compression_area_coming(struct ssd_info* ssd, struct request* request)$/;"	f
compression_cost_add_flag	initialize.h	/^unsigned int compression_cost_add_flag; \/\/ 1 means this subrequest need add compression cost time; the time value is COMPRESSION_COST_TIME_ONE_PAGE$/;"	m	struct:sub_request
compression_dirty	initialize.h	/^unsigned int* compression_dirty;\/\/ only 1 means dirty. so not = 1 means clean.$/;"	m	struct:__anon4
compression_relevant	debug.h	6;"	d
compression_size	initialize.h	/^unsigned int* compression_size;$/;"	m	struct:__anon4
compression_state	initialize.h	/^unsigned int* compression_state;\/\/ 0 means no compression, 1 means compression state$/;"	m	struct:__anon4
compression_to_uncompression	initialize.h	/^    struct _bi_list* compression_to_uncompression;$/;"	m	struct:request	typeref:struct:request::_bi_list
compute_serve_time	flash.c	/^struct ssd_info *compute_serve_time(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die,$/;"	f
controller_info	initialize.h	/^struct controller_info {$/;"	s
copy_back	flash.c	/^copy_back(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, struct sub_request *sub) {$/;"	f
copy_back_count	initialize.h	/^    int copy_back_count;$/;"	m	struct:gc_info
copy_back_count	initialize.h	/^    unsigned long copy_back_count;$/;"	m	struct:ssd_info
copy_page_number	initialize.h	/^	unsigned int copy_page_number;$/;"	m	struct:gc_operation
copy_valid_number	initialize.h	/^	unsigned int copy_valid_number;$/;"	m	struct:gc_operation
count	avlTree.h	/^    unsigned int count;                         \/*AVLæ ‘é‡Œçš„èŠ‚ç‚¹æ€»æ•°*\/$/;"	m	struct:buffer_info
count	avlTree.h	/^    unsigned int count;                         \/*AVLæ ‘é‡Œçš„èŠ‚ç‚¹æ€»æ•°*\/$/;"	m	struct:buffer_info_for_DFTL
cpu_sdram	initialize.h	/^    unsigned int cpu_sdram;         \/\/è®°å½•ç‰‡å†…æœ‰å¤šå°‘$/;"	m	struct:parameter_value
creat_sub_request	flash.c	/^creat_sub_request(struct ssd_info *ssd, unsigned int lpn, int size, unsigned int state, struct request *req,$/;"	f
createDictionary	dictionary.c	/^DICTIONARY* createDictionary(void)$/;"	f
createEntry	dictionary.c	/^DIC_ENTRY* createEntry(unsigned int value)$/;"	f
createNode	js_list.c	/^struct nodeJSList* createNode(TYPE newValue)$/;"	f
createXmatchContext	xmatchPro.c	/^void createXmatchContext(	struct xmatchContext* compContext, $/;"	f
create_and_init_bi_list	bi_list.c	/^struct _bi_list* create_and_init_bi_list(void)$/;"	f
create_and_init_bi_node	bi_list.c	/^struct _bi_node* create_and_init_bi_node(int lpn, int state)$/;"	f
create_evict_mappingtable_subrequests	ssd.c	/^struct ssd_info* create_evict_mappingtable_subrequests(struct ssd_info* ssd)$/;"	f
create_fetch_mappingtable_subrequests	ssd.c	/^struct ssd_info* create_fetch_mappingtable_subrequests(struct ssd_info* ssd)$/;"	f
create_normal_subrequests	ssd.c	/^int create_normal_subrequests(struct ssd_info* ssd)$/;"	f
create_or_notyet_evict_subrequests	initialize.h	/^    unsigned int create_or_notyet_evict_subrequests;\/\/ 1 means already create, 0 means not yet.$/;"	m	struct:request
create_or_notyet_fetch_subrequests	initialize.h	/^    unsigned int create_or_notyet_fetch_subrequests;\/\/ 1 means already create, 0 means not yet.$/;"	m	struct:request
create_or_notyet_normal_subrequests	initialize.h	/^    unsigned int create_or_notyet_normal_subrequests;\/\/ 1 means already create, 0 means not yet.$/;"	m	struct:request
current_state	initialize.h	/^    int current_state;                   \/\/channel has serveral states, including idle, command\/address transfer,data transfer,unknown$/;"	m	struct:channel_info
current_state	initialize.h	/^    int current_state;                  \/\/channel has serveral states, including idle, command\/address transfer,data transfer,unknown$/;"	m	struct:chip_info
current_state	initialize.h	/^    unsigned int current_state;        \/\/è¡¨ç¤ºè¯¥å­è¯·æ±‚æ‰€å¤„çš„çŠ¶æ€ï¼Œè§å®å®šä¹‰sub request$/;"	m	struct:sub_request
current_time	initialize.h	/^    int64_t current_time;                \/\/è®°å½•ç³»ç»Ÿæ—¶é—´$/;"	m	struct:ssd_info
current_time	initialize.h	/^    int64_t current_time;                \/\/è®°å½•è¯¥é€šé“çš„å½“å‰æ—¶é—´$/;"	m	struct:channel_info
current_time	initialize.h	/^    int64_t current_time;               \/\/è®°å½•è¯¥é€šé“çš„å½“å‰æ—¶é—´$/;"	m	struct:chip_info
current_time	initialize.h	/^    int64_t current_time;$/;"	m	struct:dram_info
current_time	initialize.h	/^    int64_t current_time;$/;"	m	struct:sub_request
debug_sign	initialize.h	/^unsigned int debug_sign;\/\/ 0 means no debug, 1 means debug.$/;"	m	struct:ssd_info
decide_gc_invoke	pagemap.c	/^int decide_gc_invoke(struct ssd_info *ssd, unsigned int channel) {$/;"	f
del_bi_list	bi_list.c	/^void del_bi_list(struct _bi_list* list)$/;"	f
del_bi_node	bi_list.c	/^void del_bi_node(struct _bi_node* node)$/;"	f
deleteNode	js_list.c	/^void deleteNode(struct nodeJSList* deletedNode, struct jsList* list)$/;"	f
delete_evict_subrequest_from_this_req	ssd.c	/^int delete_evict_subrequest_from_this_req(struct ssd_info* ssd)$/;"	f
delete_fetch_subrequest_from_this_req	ssd.c	/^int delete_fetch_subrequest_from_this_req(struct ssd_info* ssd)$/;"	f
delete_from_channel	flash.c	/^struct ssd_info *delete_from_channel(struct ssd_info *ssd, unsigned int channel, struct sub_request *sub_req) {$/;"	f
delete_gc_node	pagemap.c	/^int delete_gc_node(struct ssd_info *ssd, unsigned int channel, struct gc_operation *gc_node) {$/;"	f
delete_request_without_subs	ssd.c	/^void delete_request_without_subs(struct request* req)$/;"	f
delete_subs_bilist_in_this_req	ssd.c	/^int delete_subs_bilist_in_this_req(struct request* req, struct _bi_list* name)$/;"	f
delete_subs_in_this_req	ssd.c	/^int delete_subs_in_this_req(struct ssd_info* ssd, struct request* req)$/;"	f
delete_w_sub_request	flash.c	/^int delete_w_sub_request(struct ssd_info *ssd, unsigned int channel, struct sub_request *sub) {$/;"	f
destroyDictionary	dictionary.c	/^void destroyDictionary(DICTIONARY* dictionary)$/;"	f
destroyXmatchContext	xmatchPro.c	/^void destroyXmatchContext( struct xmatchContext* xmatchContext)$/;"	f
dftl_create_mapping_table	initialize.c	/^dftl_mapping_table_t* dftl_create_mapping_table (struct ssd_info *ssd)$/;"	f
dftl_mapping_table_t	initialize.h	/^}dftl_mapping_table_t;$/;"	t	typeref:struct:__anon4
dictionary	xmatchPro.h	/^	DICTIONARY* dictionary;$/;"	m	struct:xmatchContext
die	initialize.h	/^    unsigned int die;$/;"	m	struct:gc_operation
die	initialize.h	/^    unsigned int die;$/;"	m	struct:local
die	initialize.h	119;"	d
die_chip	initialize.h	/^    unsigned int die_chip;$/;"	m	struct:parameter_value
die_head	initialize.h	/^    struct die_info *die_head;$/;"	m	struct:chip_info	typeref:struct:chip_info::die_info
die_info	initialize.h	/^struct die_info {$/;"	s
die_num	initialize.h	/^    unsigned int die_num;               \/\/è¡¨ç¤ºä¸€ä¸ªé¢—ç²’ä¸­æœ‰å¤šå°‘ä¸ªdie$/;"	m	struct:chip_info
diff_between_FCFS_RF	initialize.h	/^unsigned int diff_between_FCFS_RF;$/;"	m	struct:ssd_info
diffcompress	diffXmatch.c	/^int diffcompress(unsigned char* ref, unsigned char* src, unsigned char* dest)$/;"	f
diffdecompress	diffXmatch.c	/^int diffdecompress(unsigned char* ref, unsigned char* src, unsigned char* dest, int inputSize)$/;"	f
dir	initialize.h	/^directory_slot_t* dir; \/\/ always maintained in DRAM;$/;"	m	struct:__anon4
dir_stat	initialize.h	/^}dir_stat;$/;"	t	typeref:enum:__anon1
direct_erase	initialize.h	/^struct direct_erase {$/;"	s
direct_erase_count	initialize.h	/^    unsigned long direct_erase_count;$/;"	m	struct:ssd_info
directory_slot_t	initialize.h	/^}directory_slot_t;$/;"	t	typeref:struct:__anon3
dirty_clean	initialize.h	/^    unsigned int dirty_clean;           \/\/it is flag of the data has been modified, one bit indicates one subpage. EX. 0001 indicates the first subpage is dirty$/;"	m	struct:buffer_group
dirty_clean	initialize.h	/^    unsigned int dirty_clean;           \/\/it is flag of the data has been modified, one bit indicates one subpage. EX. 0001 indicates the first subpage is dirty$/;"	m	struct:buffer_group_for_DFTL
distri_flag	initialize.h	/^    int distri_flag;                   \/\/ indicate whether this request has been distributed already$/;"	m	struct:request
distribute	ssd.c	/^struct ssd_info * distribute(struct ssd_info *ssd) {$/;"	f
dram	initialize.h	/^    struct dram_info *dram;$/;"	m	struct:ssd_info	typeref:struct:ssd_info::dram_info
dram_active_current	initialize.h	/^    double dram_active_current;     \/\/cpu sdram work current   uA$/;"	m	struct:parameter_value
dram_capacity	initialize.h	/^    unsigned int dram_capacity;     \/\/è®°å½•SSDä¸­DRAM capacity$/;"	m	struct:parameter_value
dram_capacity	initialize.h	/^    unsigned int dram_capacity;$/;"	m	struct:dram_info
dram_info	initialize.h	/^struct dram_info {$/;"	s
dram_parameter	initialize.h	/^struct dram_parameter {$/;"	s
dram_paramters	initialize.h	/^    struct dram_parameter *dram_paramters;$/;"	m	struct:dram_info	typeref:struct:dram_info::dram_parameter
dram_refresh_current	initialize.h	/^    double dram_refresh_current;    \/\/cpu sdram work current   uA$/;"	m	struct:parameter_value
dram_standby_current	initialize.h	/^    double dram_standby_current;    \/\/cpu sdram work current   uA$/;"	m	struct:parameter_value
dram_voltage	initialize.h	/^    double dram_voltage;            \/\/cpu sdram work voltage  V$/;"	m	struct:parameter_value
dynamic_advanced_process	flash.c	/^struct ssd_info *dynamic_advanced_process(struct ssd_info *ssd, unsigned int channel, unsigned int chip) {$/;"	f
dynamic_allocation	initialize.h	/^    int dynamic_allocation;         \/\/è®°å½•åŠ¨æ€åˆ†é…çš„æ–¹å¼$/;"	m	struct:parameter_value
energy_consumption	initialize.h	/^    double energy_consumption;         \/\/è®°å½•è¯¥è¯·æ±‚çš„èƒ½é‡æ¶ˆè€—ï¼Œå•ä½ä¸ºuJ$/;"	m	struct:request
energy_consumption	initialize.h	/^    double energy_consumption;     \/\/è¯¥planeèŠ±äº†å¤šå°‘èƒ½é‡åœ¨gcæ“ä½œä¸Š$/;"	m	struct:gc_info
entry	initialize.h	/^struct entry {$/;"	s
erase	initialize.h	/^        unsigned int erase;\/\/ erase 1 :erase. 2: verify$/;"	m	struct:gc_operation
erase_count	initialize.h	/^    int erase_count;$/;"	m	struct:gc_info
erase_count	initialize.h	/^    unsigned int erase_count;          \/\/å—çš„æ“¦é™¤æ¬¡æ•°ï¼Œè¯¥é¡¹è®°å½•åœ¨ramä¸­ï¼Œç”¨äºGC$/;"	m	struct:blk_info
erase_count	initialize.h	/^    unsigned long erase_count;$/;"	m	struct:channel_info
erase_count	initialize.h	/^    unsigned long erase_count;$/;"	m	struct:chip_info
erase_count	initialize.h	/^    unsigned long erase_count;$/;"	m	struct:ssd_info
erase_iterations	initialize.h	/^int erase_iterations;$/;"	m	struct:ssd_info
erase_node	initialize.h	/^    struct direct_erase *erase_node;    \/\/ç”¨æ¥è®°å½•å¯ä»¥ç›´æ¥åˆ é™¤çš„å—å·,åœ¨è·å–æ–°çš„ppnæ—¶ï¼Œæ¯å½“å‡ºç°invalid_page_num==64æ—¶ï¼Œå°†å…¶æ·»åŠ åˆ°è¿™ä¸ªæŒ‡é’ˆä¸Šï¼Œä¾›GCæ“ä½œæ—¶ç›´æ¥åˆ é™¤$/;"	m	struct:plane_info	typeref:struct:plane_info::direct_erase
erase_operation	pagemap.c	/^erase_operation(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane,$/;"	f
erase_planes	pagemap.c	/^erase_planes(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die1, unsigned int plane1,$/;"	f
ers_invalid	initialize.h	/^    unsigned int ers_invalid;           \/\/è®°å½•è¯¥planeä¸­æ“¦é™¤å¤±æ•ˆçš„å—æ•°$/;"	m	struct:plane_info
ers_limit	initialize.h	/^    unsigned int ers_limit;             \/\/è¯¥chipä¸­æ¯å—èƒ½å¤Ÿè¢«æ“¦é™¤çš„æ¬¡æ•°$/;"	m	struct:chip_info
ers_limit	initialize.h	/^    unsigned int ers_limit;         \/\/è®°å½•æ¯ä¸ªå—å¯æ“¦é™¤çš„æ¬¡æ•°$/;"	m	struct:parameter_value
event	initialize.h	/^    struct event_node *event;            \/\/äº‹ä»¶é˜Ÿåˆ—ï¼Œæ¯äº§ç”Ÿä¸€ä¸ªæ–°çš„äº‹ä»¶ï¼ŒæŒ‰ç…§æ—¶é—´é¡ºåºåŠ åˆ°è¿™ä¸ªé˜Ÿåˆ—ï¼Œåœ¨simulateå‡½æ•°æœ€åï¼Œæ ¹æ®è¿™ä¸ªé˜Ÿåˆ—é˜Ÿé¦–çš„æ—¶é—´ï¼Œç¡®å®šæ—¶é—´$/;"	m	struct:ssd_info	typeref:struct:ssd_info::event_node
event	initialize.h	/^    struct event_node *event;$/;"	m	struct:channel_info	typeref:struct:channel_info::event_node
event_node	initialize.h	/^struct event_node {$/;"	s
evict_sub_request	initialize.h	/^    struct sub_request * evict_sub_request; \/\/ evicting write subrequsts \/\/but we never use this memeber$/;"	m	struct:request	typeref:struct:request::sub_request
fetch_sub_request	initialize.h	/^    struct sub_request * fetch_sub_request; \/\/ fetching read subrequests \/\/but we never use this member$/;"	m	struct:request	typeref:struct:request::sub_request
file_assert	pagemap.c	/^void file_assert(int error, char *s) {$/;"	f
find_active_block	flash.c	/^find_active_block(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane) {$/;"	f
find_interleave_twoplane_page	flash.c	/^find_interleave_twoplane_page(struct ssd_info *ssd, struct sub_request *one_page, unsigned int command) {$/;"	f
find_interleave_twoplane_sub_request	flash.c	/^find_interleave_twoplane_sub_request(struct ssd_info *ssd, unsigned int channel, struct sub_request *sub_request_one,$/;"	f
find_level_page	flash.c	/^Status find_level_page(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die,$/;"	f
find_location	pagemap.c	/^struct local *find_location(struct ssd_info *ssd, unsigned int ppn) {$/;"	f
find_nearest_event	ssd.c	/^int64_t find_nearest_event(struct ssd_info *ssd) {$/;"	f
find_ppn	pagemap.c	/^find_ppn(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane,$/;"	f
find_read_sub_request	flash.c	/^find_read_sub_request(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die) {$/;"	f
find_write_sub_request	flash.c	/^struct sub_request *find_write_sub_request(struct ssd_info *ssd, unsigned int channel) {$/;"	f
flag	initialize.h	/^    int flag;                            \/\/indicates if this node is the last 20% of the LRU list$/;"	m	struct:buffer_group
flag	initialize.h	/^    int flag;                            \/\/indicates if this node is the last 20% of the LRU list$/;"	m	struct:buffer_group_for_DFTL
flag	initialize.h	/^    int flag;$/;"	m	struct:ssd_info
flash_page_state_modify	flash.c	/^flash_page_state_modify(struct ssd_info *ssd, struct sub_request *sub, unsigned int channel, unsigned int chip,$/;"	f
flush_mappingtable_into_files	ssd.c	/^int flush_mappingtable_into_files(struct ssd_info *ssd, char* filename)$/;"	f
fp_number_subrequests_txt	initialize.h	/^    FILE * fp_number_subrequests_txt;$/;"	m	struct:ssd_info
fp_number_subrequests_txt_name	initialize.h	/^    char fp_number_subrequests_txt_name[30];$/;"	m	struct:ssd_info
free	avlTree.h	/^    int (*free)(TREE_NODE *);$/;"	m	struct:buffer_info
free	avlTree.h	/^    int (*free)(TREE_NODE *);$/;"	m	struct:buffer_info_for_DFTL
freeFunc	initialize.c	/^extern int freeFunc(TREE_NODE *pNode) {$/;"	f
free_all_node	ssd.c	/^void free_all_node(struct ssd_info *ssd) {$/;"	f
free_page	initialize.h	/^    unsigned int free_page;             \/\/è¯¥planeä¸­æœ‰å¤šå°‘free page$/;"	m	struct:plane_info
free_page_num	initialize.h	/^    unsigned int free_page_num;        \/\/è®°å½•è¯¥å—ä¸­çš„freeé¡µä¸ªæ•°ï¼ŒåŒä¸Š$/;"	m	struct:blk_info
free_state	initialize.h	/^    int free_state;                    \/\/each bit indicates the subpage is free or occupted. 1 indicates that the bit is free and 0 indicates that the bit is used$/;"	m	struct:page_info
frequency	initialize.h	/^    unsigned int frequency;             \/\/è¡¨ç¤ºè¯¥æ§åˆ¶å™¨çš„å·¥ä½œé¢‘ç‡$/;"	m	struct:controller_info
gc	initialize.h	/^    int gc;                         \/\/è®°å½•gcç­–ç•¥$/;"	m	struct:parameter_value
gc	pagemap.c	/^unsigned int gc(struct ssd_info *ssd, unsigned int channel, unsigned int flag) {$/;"	f
gc_command	initialize.h	/^    struct gc_operation *gc_command;     \/\/è®°å½•éœ€è¦äº§ç”Ÿgcçš„ä½ç½®$/;"	m	struct:channel_info	typeref:struct:channel_info::gc_operation
gc_copy_back	initialize.h	/^    unsigned long gc_copy_back;$/;"	m	struct:ssd_info
gc_direct_erase	pagemap.c	/^gc_direct_erase(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane) {$/;"	f
gc_for_channel	pagemap.c	/^Status gc_for_channel(struct ssd_info *ssd, unsigned int channel) {$/;"	f
gc_hard_threshold	initialize.h	/^    float gc_hard_threshold;        \/\/æ™®é€šç­–ç•¥ä¸­ç”¨ä¸åˆ°è¯¥å‚æ•°ï¼Œåªæœ‰åœ¨ä¸»åŠ¨å†™ç­–ç•¥ä¸­ï¼Œå½“æ»¡è¶³è¿™ä¸ªé˜ˆå€¼æ—¶ï¼ŒGCæ“ä½œä¸å¯ä¸­æ–­$/;"	m	struct:parameter_value
gc_info	initialize.h	/^struct gc_info {$/;"	s
gc_operation	initialize.h	/^struct gc_operation {$/;"	s
gc_read_inner	initialize.h	/^        unsigned int gc_read_inner;$/;"	m	struct:gc_operation
gc_request	initialize.h	/^    unsigned int gc_request;             \/\/è®°å½•åœ¨SSDä¸­ï¼Œå½“å‰æ—¶åˆ»æœ‰å¤šå°‘gcæ“ä½œçš„è¯·æ±‚$/;"	m	struct:ssd_info
gc_suspend_doing	initialize.h	/^unsigned int gc_suspend_doing;$/;"	m	struct:ssd_info
gc_suspend_times	initialize.h	/^unsigned int gc_suspend_times;\/\/ statistic for gc suspend times.$/;"	m	struct:ssd_info
gc_threshold	initialize.h	/^    float gc_threshold;             \/\/å½“è¾¾åˆ°è¿™ä¸ªé˜ˆå€¼æ—¶ï¼Œå¼€å§‹GCæ“ä½œï¼Œåœ¨ä¸»åŠ¨å†™ç­–ç•¥ä¸­ï¼Œå¼€å§‹GCæ“ä½œåå¯ä»¥ä¸´æ—¶ä¸­æ–­GCæ“ä½œï¼ŒæœåŠ¡æ–°åˆ°çš„è¯·æ±‚ï¼›åœ¨æ™®é€šç­–ç•¥ä¸­ï¼ŒGCä¸å¯ä¸­æ–­$/;"	m	struct:parameter_value
gc_try_to_suspend_function	flash.c	/^int gc_try_to_suspend_function(struct ssd_info *ssd,  struct gc_operation *gc_node, unsigned int channel, unsigned int chip, unsigned int current_state, unsigned int next_state, int time)$/;"	f
gc_write_inner	initialize.h	/^        unsigned int gc_write_inner;$/;"	m	struct:gc_operation
getEntry	dictionary.c	/^DIC_ENTRY* getEntry(int index, DICTIONARY* dictionary)$/;"	f
getNextEntry	dictionary.c	/^DIC_ENTRY* getNextEntry(DIC_ENTRY* entry)$/;"	f
getNode	js_list.c	/^struct nodeJSList* getNode(int index, struct jsList* list)$/;"	f
getOrgData	xmatchPro.c	/^unsigned int getOrgData(int matchType, unsigned int refValue, unsigned int uniqueValue)$/;"	f
getPrevEntry	dictionary.c	/^DIC_ENTRY* getPrevEntry(DIC_ENTRY* entry)$/;"	f
getValueOfEntry	dictionary.c	/^unsigned int getValueOfEntry(DIC_ENTRY* entry)$/;"	f
get_compression_translation_page_size	ssd.c	/^void get_compression_translation_page_size(struct ssd_info* ssd)$/;"	f
get_no_repeat_pages_number_from_lpns	ssd.c	/^void get_no_repeat_pages_number_from_lpns(struct ssd_info* ssd, struct request* req,struct _bi_list*  temp_bilist, int* input)$/;"	f
get_ppn	pagemap.c	/^get_ppn(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane,$/;"	f
get_ppn_for_advanced_commands	flash.c	/^get_ppn_for_advanced_commands(struct ssd_info *ssd, unsigned int channel, unsigned int chip, struct sub_request **subs,$/;"	f
get_ppn_for_gc	pagemap.c	/^get_ppn_for_gc(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane) {$/;"	f
get_ppn_for_normal_command	flash.c	/^get_ppn_for_normal_command(struct ssd_info *ssd, unsigned int channel, unsigned int chip, struct sub_request *sub) {$/;"	f
get_ppn_for_pre_process	pagemap.c	/^unsigned int get_ppn_for_pre_process(struct ssd_info *ssd, unsigned int lsn) {$/;"	f
get_ppn_in_different_case	pagemap.c	/^unsigned int  get_ppn_in_different_case(struct ssd_info* ssd, unsigned int channel, unsigned int chip,unsigned int die,unsigned int plane,unsigned int block,unsigned int page)$/;"	f
get_realsize_inbyte_byposition_in_mt	ssd.c	/^int get_realsize_inbyte_byposition_in_mt(struct ssd_info* ssd, int lpn) $/;"	f
get_requests	ssd.c	/^int get_requests(struct ssd_info *ssd) {$/;"	f
get_size_from_compression_to_uncompression	ssd.c	/^int get_size_from_compression_to_uncompression(struct ssd_info* ssd, struct request* request)$/;"	f
get_the_previous_sub	flash.c	/^struct sub_request* get_the_previous_sub(struct ssd_info* ssd, unsigned int channel, struct sub_request * sub)$/;"	f
get_translation_number_by_data_lpn	ssd.c	/^int get_translation_number_by_data_lpn(int data_lpn)$/;"	f
get_uncompression_tail_page_compressed_size	ssd.c	/^int get_uncompression_tail_page_compressed_size(struct ssd_info* ssd, int off_set)$/;"	f
go_one_step	flash.c	/^Status go_one_step(struct ssd_info *ssd, struct sub_request *sub1, struct sub_request *sub2, unsigned int aim_state,$/;"	f
greed_CB_ad	initialize.h	/^    int greed_CB_ad;                \/\/0 don't use copyback advanced commands greedily; 1 use copyback advanced commands greedily$/;"	m	struct:parameter_value
greed_MPW_ad	initialize.h	/^    int greed_MPW_ad;               \/\/0 don't use multi-plane write advanced commands greedily; 1 use multi-plane write advanced commands greedily$/;"	m	struct:parameter_value
group	initialize.h	/^    unsigned int group;                 \/\/the first data logic sector number of a group stored in buffer$/;"	m	struct:buffer_group_for_DFTL
group	initialize.h	/^    unsigned int group;                 \/\/the first data logic sector number of a group stored in buffer\/\/ or other lpn value or translation page number and so on.$/;"	m	struct:buffer_group
gx	Session.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
gx	Session.vim	/^vmap gx <Plug>NetrwBrowseXVis$/;"	m
head	js_list.h	/^	struct nodeJSList* head;$/;"	m	struct:jsList	typeref:struct:jsList::nodeJSList
hit_in_uncompression_buffer_number	initialize.h	/^    int hit_in_uncompression_buffer_number;$/;"	m	struct:request
id	initialize.h	/^unsigned long id;$/;"	m	struct:__anon3
if_need_movement_between_com_and_uncom_flag_and_page_numbers	initialize.h	/^    int if_need_movement_between_com_and_uncom_flag_and_page_numbers;\/\/ 0 means no page, other number means the real number of pages.$/;"	m	struct:request
initList	js_list.c	/^void initList(struct jsList* list)$/;"	f
initialize_block	initialize.c	/^struct blk_info *initialize_block(struct blk_info *p_block, struct parameter_value *parameter) {$/;"	f
initialize_channels	initialize.c	/^struct ssd_info *initialize_channels(struct ssd_info *ssd) {$/;"	f
initialize_chip	initialize.c	/^struct chip_info *initialize_chip(struct chip_info *p_chip, struct parameter_value *parameter, long long current_time) {$/;"	f
initialize_die	initialize.c	/^struct die_info *initialize_die(struct die_info *p_die, struct parameter_value *parameter, long long current_time) {$/;"	f
initialize_dram	initialize.c	/^struct dram_info *initialize_dram(struct ssd_info *ssd) {$/;"	f
initialize_page	initialize.c	/^struct page_info *initialize_page(struct page_info *p_page) {$/;"	f
initialize_plane	initialize.c	/^struct plane_info *initialize_plane(struct plane_info *p_plane, struct parameter_value *parameter) {$/;"	f
initiation	initialize.c	/^struct ssd_info *initiation(struct ssd_info *ssd) {$/;"	f
input	xmatchPro.h	/^	unsigned int* input;$/;"	m	struct:xmatchContext
inputSize	xmatchPro.h	/^	int inputSize;$/;"	m	struct:xmatchContext
insert2DFTL_UNCOM_buffer	ssd.c	/^int insert2DFTL_UNCOM_buffer(struct ssd_info* ssd, struct request* req)$/;"	f
insert2DFTL_buffer	ssd.c	/^int insert2DFTL_buffer(struct ssd_info* ssd, struct request* req)$/;"	f
insert2buffer	flash.c	/^insert2buffer(struct ssd_info *ssd, unsigned int lpn, int state, struct sub_request *sub, struct request *req) {$/;"	f
insertEntry	dictionary.c	/^int insertEntry(int index, DIC_ENTRY* entry, DICTIONARY* dictionary)$/;"	f
insertNode	js_list.c	/^int insertNode(int index, struct nodeJSList* newNode, struct jsList* list)$/;"	f
inter_mplane_count	initialize.h	/^    unsigned long inter_mplane_count;$/;"	m	struct:ssd_info
inter_mplane_prog_count	initialize.h	/^    unsigned long inter_mplane_prog_count;$/;"	m	struct:ssd_info
interference_stuffed_length	initialize.h	/^int interference_stuffed_length;$/;"	m	struct:ssd_info
interference_stuffed_length_during_gc	initialize.h	/^int interference_stuffed_length_during_gc;$/;"	m	struct:ssd_info
interleave_count	initialize.h	/^    unsigned long interleave_count;$/;"	m	struct:ssd_info
interleave_erase_count	initialize.h	/^    unsigned long interleave_erase_count;$/;"	m	struct:ssd_info
interleave_mplane_erase_count	initialize.h	/^    unsigned long interleave_mplane_erase_count;$/;"	m	struct:ssd_info
interleave_read_count	initialize.h	/^    unsigned long interleave_read_count;$/;"	m	struct:ssd_info
interleaving	initialize.h	/^    int interleaving;$/;"	m	struct:parameter_value
interrupt_gc	pagemap.c	/^int interrupt_gc(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane,$/;"	f
invalid_page_num	initialize.h	/^    unsigned int invalid_page_num;     \/\/è®°å½•è¯¥å—ä¸­å¤±æ•ˆé¡µçš„ä¸ªæ•°ï¼ŒåŒä¸Š$/;"	m	struct:blk_info
is_under_load	initialize.h	/^int is_under_load;$/;"	m	struct:__anon3
isnot_repeat_in_bilist	ssd.c	/^int isnot_repeat_in_bilist(struct _bi_list* bilist, int lpn)$/;"	f
j	Session.vim	/^nnoremap <buffer> j gj$/;"	m
jsList	js_list.h	/^struct jsList$/;"	s
judge_write_existing_in_chip	flash.c	/^int judge_write_existing_in_chip(struct ssd_info *ssd, int channel, int chip)\/\/ return 1 means write exit in this chip$/;"	f
judging_read_in_gc_chip	ssd.c	/^int judging_read_in_gc_chip(struct ssd_info *ssd, int channel)$/;"	f
k	Session.vim	/^nnoremap <buffer> k gk$/;"	m
keyCompare	avlTree.h	/^    int (*keyCompare)(TREE_NODE *, TREE_NODE *);$/;"	m	struct:buffer_info
keyCompare	avlTree.h	/^    int (*keyCompare)(TREE_NODE *, TREE_NODE *);$/;"	m	struct:buffer_info_for_DFTL
keyCompareFunc	initialize.c	/^extern int keyCompareFunc(TREE_NODE *p, TREE_NODE *p1) {$/;"	f
keyCompareFunc_for_DFTL	initialize.c	/^extern int keyCompareFunc_for_DFTL(TREE_NODE *p, TREE_NODE *p1) {$/;"	f
last_page_in_victim_deal	initialize.h	/^        unsigned int last_page_in_victim_deal;    $/;"	m	struct:gc_operation
last_sign	initialize.h	/^   int last_sign;$/;"	m	struct:sub_request
last_total_available_pages_number	initialize.h	/^int last_total_available_pages_number;$/;"	m	struct:ssd_info
last_write_page	initialize.h	/^    int last_write_page;               \/\/è®°å½•æœ€è¿‘ä¸€æ¬¡å†™æ“ä½œæ‰§è¡Œçš„é¡µæ•°,-1è¡¨ç¤ºè¯¥å—æ²¡æœ‰ä¸€é¡µè¢«å†™è¿‡$/;"	m	struct:blk_info
left_child	avlTree.h	/^    struct _AVL_TREE_NODE *left_child;$/;"	m	struct:_AVL_TREE_NODE	typeref:struct:_AVL_TREE_NODE::_AVL_TREE_NODE
len	bi_list.h	/^int len;$/;"	m	struct:_bi_list
load_parameters	initialize.c	/^struct parameter_value *load_parameters(char parameter_file[30]) {$/;"	f
local	initialize.h	/^struct local {$/;"	s
location	initialize.h	/^    struct local *location;           \/\/åœ¨é™æ€åˆ†é…å’Œæ··åˆåˆ†é…æ–¹å¼ä¸­ï¼Œå·²çŸ¥lpnå°±çŸ¥é“è¯¥lpnè¯¥åˆ†é…åˆ°é‚£ä¸ªchannelï¼Œchipï¼Œdieï¼Œplaneï¼Œè¿™ä¸ªç»“æ„ä½“ç”¨æ¥ä¿å­˜è®¡ç®—å¾—åˆ°çš„åœ°å€$/;"	m	struct:sub_request	typeref:struct:sub_request::local
lpn	initialize.h	/^    unsigned int lpn;                  \/\/è¿™é‡Œè¡¨ç¤ºè¯¥å­è¯·æ±‚çš„é€»è¾‘é¡µå·$/;"	m	struct:sub_request
lpn	initialize.h	/^    unsigned int lpn;$/;"	m	struct:page_info
lpn2ppn	ssd.c	/^unsigned int lpn2ppn(struct ssd_info *ssd, unsigned int lsn) {$/;"	f
lpn_and_state	bi_list.h	/^int lpn_and_state[2];$/;"	m	struct:_bi_node
lpush	bi_list.c	/^void lpush(struct _bi_list* list, int lpn, int state)$/;"	f
lsn	initialize.h	/^    unsigned int lsn;                  \/\/è¯·æ±‚çš„èµ·å§‹åœ°å€ï¼Œé€»è¾‘åœ°å€$/;"	m	struct:request
m_plane_prog_count	initialize.h	/^    unsigned long m_plane_prog_count;$/;"	m	struct:ssd_info
m_plane_read_count	initialize.h	/^    unsigned long m_plane_read_count;$/;"	m	struct:ssd_info
main	ssd.c	/^int main() {$/;"	f
make_aged	ssd.c	/^struct ssd_info *make_aged(struct ssd_info *ssd) {$/;"	f
make_level_page	flash.c	/^Status make_level_page(struct ssd_info *ssd, struct sub_request *sub0, struct sub_request *sub1) {$/;"	f
make_real_evict_pages_for_compression_part	ssd.c	/^void make_real_evict_pages_for_compression_part(struct ssd_info* ssd, struct request* request, int should_evict_size)$/;"	f
make_same_level	flash.c	/^make_same_level(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane,$/;"	f
map	initialize.h	/^    struct map_info *map;$/;"	m	struct:dram_info	typeref:struct:dram_info::map_info
map_entry	initialize.h	/^    struct entry *map_entry;            \/\/è¯¥é¡¹æ˜¯æ˜ å°„è¡¨ç»“æ„ä½“æŒ‡é’ˆ,each entry indicate a mapping information$/;"	m	struct:map_info	typeref:struct:map_info::entry
map_info	initialize.h	/^struct map_info {$/;"	s
mapping_entry_size	initialize.h	/^unsigned long mapping_entry_size;$/;"	m	struct:__anon4
mapping_entry_t	initialize.h	/^}mapping_entry_t;$/;"	t	typeref:struct:__anon2
matchTypeToNumMatch	xmatchPro.c	/^int matchTypeToNumMatch[16] = {4, 3, 3, 2, 3, 2, 2, 0, 3, 2, 2, 0, 2, 0, 0, 0};$/;"	v
max_buffer_sector	avlTree.h	/^    unsigned int max_buffer_sector;$/;"	m	struct:buffer_info
max_buffer_size	avlTree.h	/^    unsigned int max_buffer_size; \/\/ can be maximum 4GB size here.$/;"	m	struct:buffer_info_for_DFTL
max_cached_dir_slots_sizein_byte	initialize.h	/^unsigned long max_cached_dir_slots_sizein_byte;\/\/$/;"	m	struct:__anon4
max_cached_entries_sizein_byte	initialize.h	/^unsigned long max_cached_entries_sizein_byte;\/\/$/;"	m	struct:__anon4
max_lsn	initialize.h	/^    unsigned int max_lsn;$/;"	m	struct:ssd_info
me	initialize.h	/^mapping_entry_t * me; \/\/ here is an array for entries in one dir. also it is not one translation page,but it can be a translation page.$/;"	m	struct:__anon3
min_lsn	initialize.h	/^    unsigned int min_lsn;$/;"	m	struct:ssd_info
missing_in_DFTL_buffer_lpn_data	initialize.h	/^    struct _bi_list* missing_in_DFTL_buffer_lpn_data;$/;"	m	struct:request	typeref:struct:request::_bi_list
missing_in_data_buffer_lpn_data	initialize.h	/^    struct _bi_list* missing_in_data_buffer_lpn_data;$/;"	m	struct:request	typeref:struct:request::_bi_list
missing_mapping_and_cannot_get_traceline	initialize.h	/^int missing_mapping_and_cannot_get_traceline;\/\/ 0 means can get new traceline. 1 is on the contrary$/;"	m	struct:ssd_info
moveFront	dictionary.c	/^int moveFront(DIC_ENTRY* entry, DICTIONARY* dictionary)$/;"	f
move_between_compression_and_uncompression	ssd.c	/^void move_between_compression_and_uncompression(struct ssd_info* ssd, struct request* request)$/;"	f
move_page	pagemap.c	/^Status move_page(struct ssd_info *ssd, struct local *location, unsigned int *transfer_size) {$/;"	f
move_pages_from_compression_to_uncompression	ssd.c	/^int move_pages_from_compression_to_uncompression(struct ssd_info* ssd, struct request* request)$/;"	f
move_pages_from_uncompression_to_compression	ssd.c	/^int move_pages_from_uncompression_to_compression(struct ssd_info* ssd, struct request* request)$/;"	f
mplane_erase_conut	initialize.h	/^    unsigned long mplane_erase_conut;$/;"	m	struct:ssd_info
mt	initialize.h	/^    dftl_mapping_table_t* mt; \/\/ only data buffer is in dram, but the mappingtable buffer is in dram->mt.$/;"	m	struct:dram_info
need_distr_flag	initialize.h	/^    unsigned int *need_distr_flag;$/;"	m	struct:request
new_services_2_write	flash.c	/^int  new_services_2_write(struct ssd_info *ssd, unsigned int channel, unsigned int *channel_busy_flag,$/;"	f
next	avlTree.h	/^    struct _AVL_TREE_NODE *next;$/;"	m	struct:_AVL_TREE_NODE	typeref:struct:_AVL_TREE_NODE::_AVL_TREE_NODE
nextNode	bi_list.h	/^struct _bi_node* nextNode;$/;"	m	struct:_bi_node	typeref:struct:_bi_node::_bi_node
nextNode	js_list.h	/^	struct nodeJSList* nextNode;$/;"	m	struct:nodeJSList	typeref:struct:nodeJSList::nodeJSList
next_node	initialize.h	/^    struct direct_erase *next_node;$/;"	m	struct:direct_erase	typeref:struct:direct_erase::direct_erase
next_node	initialize.h	/^    struct event_node *next_node;$/;"	m	struct:event_node	typeref:struct:event_node::event_node
next_node	initialize.h	/^    struct gc_operation *next_node;$/;"	m	struct:gc_operation	typeref:struct:gc_operation::gc_operation
next_node	initialize.h	/^    struct request *next_node;         \/\/æŒ‡å‘ä¸‹ä¸€ä¸ªè¯·æ±‚ç»“æ„ä½“$/;"	m	struct:request	typeref:struct:request::request
next_node	initialize.h	/^    struct sub_request *next_node;    \/\/æŒ‡å‘åŒä¸€ä¸ªchannelä¸­ä¸‹ä¸€ä¸ªå­è¯·æ±‚ç»“æ„ä½“$/;"	m	struct:sub_request	typeref:struct:sub_request::sub_request
next_request_time	initialize.h	/^    int64_t next_request_time;$/;"	m	struct:ssd_info
next_state	initialize.h	/^    int next_state;$/;"	m	struct:channel_info
next_state	initialize.h	/^    int next_state;$/;"	m	struct:chip_info
next_state	initialize.h	/^    unsigned int next_state;$/;"	m	struct:sub_request
next_state_predict_time	initialize.h	/^    int64_t next_state_predict_time;     \/\/the predict time of next state, used to decide the sate at the moment$/;"	m	struct:channel_info
next_state_predict_time	initialize.h	/^    int64_t next_state_predict_time;    \/\/the predict time of next state, used to decide the sate at the moment$/;"	m	struct:chip_info
next_state_predict_time	initialize.h	/^    int64_t next_state_predict_time;$/;"	m	struct:sub_request
next_subs	initialize.h	/^    struct sub_request *next_subs;    \/\/æŒ‡å‘å±äºåŒä¸€ä¸ªrequestçš„å­è¯·æ±‚$/;"	m	struct:sub_request	typeref:struct:sub_request::sub_request
no_buffer_distribute	ssd.c	/^struct ssd_info *no_buffer_distribute(struct ssd_info *ssd) $/;"	f
no_greedy_RF_suspension	ssd.c	/^int no_greedy_RF_suspension(struct ssd_info *ssd)$/;"	f
node	initialize.h	/^    TREE_NODE node;                     \/\/æ ‘èŠ‚ç‚¹çš„ç»“æ„ä¸€å®šè¦æ”¾åœ¨ç”¨æˆ·è‡ªå®šä¹‰ç»“æ„çš„æœ€å‰é¢ï¼Œæ³¨æ„!$/;"	m	struct:buffer_group
node	initialize.h	/^    TREE_NODE node;                     \/\/æ ‘èŠ‚ç‚¹çš„ç»“æ„ä¸€å®šè¦æ”¾åœ¨ç”¨æˆ·è‡ªå®šä¹‰ç»“æ„çš„æœ€å‰é¢ï¼Œæ³¨æ„!$/;"	m	struct:buffer_group_for_DFTL
nodeJSList	js_list.h	/^struct nodeJSList$/;"	s
node_head	bi_list.h	/^struct _bi_node* node_head;$/;"	m	struct:_bi_list	typeref:struct:_bi_list::_bi_node
node_isnot_in_DFTL_buffer	ssd.c	/^struct buffer_group* node_isnot_in_DFTL_buffer(struct ssd_info* ssd, int lpn) $/;"	f
node_isnot_in_two_DIFF_DFTL_buffer	ssd.c	/^struct buffer_group* node_isnot_in_two_DIFF_DFTL_buffer(struct ssd_info* ssd, int lpn, int* sign)$/;"	f
node_tail	bi_list.h	/^struct _bi_node* node_tail;$/;"	m	struct:_bi_list	typeref:struct:_bi_list::_bi_node
now_cached_dir_slots_sizein_byte	initialize.h	/^unsigned long now_cached_dir_slots_sizein_byte;\/\/$/;"	m	struct:__anon4
now_cached_entries_sizein_byte	initialize.h	/^unsigned long now_cached_entries_sizein_byte;\/\/$/;"	m	struct:__anon4
nr_entries_per_dir_slot	initialize.h	/^unsigned long nr_entries_per_dir_slot;$/;"	m	struct:__anon4
nr_total_dir_slots	initialize.h	/^unsigned long nr_total_dir_slots;$/;"	m	struct:__anon4
numEntry	dictionary.c	/^int numEntry(DICTIONARY* dictionary)$/;"	f
numMatch	xmatchPro.c	/^int numMatch(int matchType)$/;"	f
numNode	js_list.h	/^	int numNode;$/;"	m	struct:jsList
numValidBit	xmatchPro.h	/^	int	numValidBit;$/;"	m	struct:xmatchContext
num_w_cycle	initialize.h	/^int num_w_cycle; \/\/ number of the iterarions now$/;"	m	struct:chip_info
operating_current	initialize.h	/^    double operating_current;       \/\/NAND FLASHçš„å·¥ä½œç”µæµå•ä½æ˜¯uA$/;"	m	struct:parameter_value
operation	initialize.h	/^    unsigned int operation;            \/\/è¡¨ç¤ºè¯¥å­è¯·æ±‚çš„ç±»å‹ï¼Œé™¤äº†è¯»1 å†™0ï¼Œè¿˜æœ‰æ“¦é™¤ï¼Œtwo planeç­‰æ“ä½œ$/;"	m	struct:sub_request
operation	initialize.h	/^    unsigned int operation;            \/\/è¯·æ±‚çš„ç§ç±»ï¼Œ1ä¸ºè¯»ï¼Œ0ä¸ºå†™$/;"	m	struct:request
orderListInsert	avlTree.c	/^static int orderListInsert$/;"	f	file:
orderListRemove	avlTree.c	/^static int orderListRemove$/;"	f	file:
original_total_pages_number	initialize.h	/^int original_total_pages_number;$/;"	m	struct:ssd_info
output	xmatchPro.h	/^	unsigned int* output;$/;"	m	struct:xmatchContext
outputfile	initialize.h	/^    FILE *outputfile;$/;"	m	struct:ssd_info
outputfilename	initialize.h	/^    char outputfilename[30];$/;"	m	struct:ssd_info
overprovide	initialize.h	/^    float overprovide;$/;"	m	struct:parameter_value
p	Session.vim	/^nnoremap <buffer> p :wincmd p$/;"	m
pListHeader	avlTree.h	/^    TREE_NODE *pListHeader;$/;"	m	struct:buffer_info
pListHeader	avlTree.h	/^    TREE_NODE *pListHeader;$/;"	m	struct:buffer_info_for_DFTL
pListTail	avlTree.h	/^    TREE_NODE *pListTail;$/;"	m	struct:buffer_info
pListTail	avlTree.h	/^    TREE_NODE *pListTail;$/;"	m	struct:buffer_info_for_DFTL
pTreeHeader	avlTree.h	/^    TREE_NODE *pTreeHeader;                     \/*for search target lsn is LRU table*\/$/;"	m	struct:buffer_info
pTreeHeader	avlTree.h	/^    TREE_NODE *pTreeHeader;                     \/*for search target lsn is LRU table*\/$/;"	m	struct:buffer_info_for_DFTL
page	initialize.h	/^    unsigned int page;            \/\/è¯¥å‚æ•°åªåœ¨å¯ä¸­æ–­çš„gcå‡½æ•°ä¸­ä½¿ç”¨ï¼ˆgc_interruptï¼‰ï¼Œç”¨æ¥è®°å½•å·²ç»å®Œæˆçš„æ•°æ®è¿ç§»çš„é¡µå·$/;"	m	struct:gc_operation
page	initialize.h	/^    unsigned int page;$/;"	m	struct:local
page	initialize.h	/^    unsigned int page;$/;"	m	struct:ssd_info
page_block	initialize.h	/^    unsigned int page_block;$/;"	m	struct:parameter_value
page_capacity	initialize.h	/^    unsigned int page_capacity;$/;"	m	struct:parameter_value
page_head	initialize.h	/^    struct page_info *page_head;       \/\/è®°å½•æ¯ä¸€å­é¡µçš„çŠ¶æ€$/;"	m	struct:blk_info	typeref:struct:blk_info::page_info
page_info	initialize.h	/^struct page_info {                      \/\/lpnè®°å½•è¯¥ç‰©ç†é¡µå­˜å‚¨çš„é€»è¾‘é¡µï¼Œå½“è¯¥é€»è¾‘é¡µæœ‰æ•ˆæ—¶ï¼Œvalid_stateå¤§äº0ï¼Œfree_stateå¤§äº0ï¼›$/;"	s
page_num_block	initialize.h	/^    unsigned int page_num_block;        \/\/indicate how many pages in a block$/;"	m	struct:chip_info
parameter	initialize.h	/^    struct parameter_value *parameter;   \/\/SSDå‚æ•°å› å­$/;"	m	struct:ssd_info	typeref:struct:ssd_info::parameter_value
parameter_value	initialize.h	/^struct parameter_value {$/;"	s
parameterfilename	initialize.h	/^    char parameterfilename[30];$/;"	m	struct:ssd_info
phyaddr	initialize.h	/^struct local  phyaddr; \/\/dir's physicallocaton$/;"	m	struct:__anon3	typeref:struct:__anon3::local
phyaddr	initialize.h	/^struct local phyaddr;$/;"	m	struct:__anon2	typeref:struct:__anon2::local
pipelining	initialize.h	/^    int pipelining;$/;"	m	struct:parameter_value
plane	initialize.h	/^    unsigned int plane;$/;"	m	struct:gc_operation
plane	initialize.h	/^    unsigned int plane;$/;"	m	struct:local
plane_die	initialize.h	/^    unsigned int plane_die;$/;"	m	struct:parameter_value
plane_head	initialize.h	/^    struct plane_info *plane_head;$/;"	m	struct:die_info	typeref:struct:die_info::plane_info
plane_info	initialize.h	/^struct plane_info {$/;"	s
plane_num_die	initialize.h	/^    unsigned int plane_num_die;         \/\/indicate how many planes in a die$/;"	m	struct:chip_info
pn	initialize.h	/^    unsigned int pn;                \/\/ç‰©ç†å·ï¼Œæ—¢å¯ä»¥è¡¨ç¤ºç‰©ç†é¡µå·ï¼Œä¹Ÿå¯ä»¥è¡¨ç¤ºç‰©ç†å­é¡µå·ï¼Œä¹Ÿå¯ä»¥è¡¨ç¤ºç‰©ç†å—å·$/;"	m	struct:entry
polling_whether_finish_evict_subrequests	ssd.c	/^int polling_whether_finish_evict_subrequests(struct ssd_info* ssd)$/;"	f
polling_whether_finish_fetch_subrequests	ssd.c	/^int polling_whether_finish_fetch_subrequests(struct ssd_info* ssd)$/;"	f
pos_in_copy	initialize.h	/^	unsigned int pos_in_copy;$/;"	m	struct:gc_operation
power	initialize.h	/^    float power;                        \/\/è¡¨ç¤ºæ§åˆ¶å™¨å•ä½æ—¶é—´çš„èƒ½è€—$/;"	m	struct:controller_info
ppn	initialize.h	/^    int ppn;$/;"	m	struct:sub_request
pre_node	initialize.h	/^    struct event_node *pre_node;$/;"	m	struct:event_node	typeref:struct:event_node::event_node
pre_process_page	pagemap.c	/^struct ssd_info *pre_process_page(struct ssd_info *ssd) {$/;"	f
predict_time	initialize.h	/^    int64_t predict_time;            \/\/è®°å½•è¿™ä¸ªæ—¶é—´å¼€å§‹çš„é¢„è®¡æ—¶é—´ï¼Œé˜²æ­¢æå‰æ‰§è¡Œè¿™ä¸ªæ—¶é—´$/;"	m	struct:event_node
prev	avlTree.h	/^    struct _AVL_TREE_NODE *prev;$/;"	m	struct:_AVL_TREE_NODE	typeref:struct:_AVL_TREE_NODE::_AVL_TREE_NODE
prevNode	bi_list.h	/^struct _bi_node* prevNode;$/;"	m	struct:_bi_node	typeref:struct:_bi_node::_bi_node
prevNode	js_list.h	/^	struct nodeJSList* prevNode;$/;"	m	struct:nodeJSList	typeref:struct:nodeJSList::nodeJSList
printfBinary	xmatchPro.c	/^void printfBinary(unsigned int input)$/;"	f
printf_every_chip_read_subrequest	ssd.c	/^int printf_every_chip_read_subrequest(struct ssd_info *ssd)$/;"	f
printf_every_chip_static_subrequest	ssd.c	/^int printf_every_chip_static_subrequest(struct ssd_info *ssd)$/;"	f
printf_gc_node_information	ssd.c	/^int printf_gc_node_information(struct gc_operation* gc_node)$/;"	f
printf_mappingtable_relevant_subrequest_in_different_process	ssd.c	/^void printf_mappingtable_relevant_subrequest_in_different_process(struct ssd_info* ssd, struct request* req)$/;"	f
printf_one_request_subrequests	ssd.c	/^void printf_one_request_subrequests(struct ssd_info* ssd, struct request* request)$/;"	f
printf_read_request_need_distr_flag_value_and_illustion	ssd.c	/^void printf_read_request_need_distr_flag_value_and_illustion(struct ssd_info* ssd, struct request* req) $/;"	f
printf_requests_basic_paramters_value	ssd.c	/^void printf_requests_basic_paramters_value (struct ssd_info* ssd,struct request* new_request)$/;"	f
printf_ssd_gc_node	ssd.c	/^void printf_ssd_gc_node(struct ssd_info *ssd)$/;"	f
printf_ssd_request_queue	ssd.c	/^void printf_ssd_request_queue(struct ssd_info *ssd)$/;"	f
printf_write_request_need_distr_flag_value_and_illustion	ssd.c	/^void printf_write_request_need_distr_flag_value_and_illustion(struct ssd_info* ssd,struct request* new_request)$/;"	f
printfsub_request_status	ssd.c	/^void printfsub_request_status(struct ssd_info *ssd)$/;"	f
priority	initialize.h	/^    unsigned int priority;        \/\/è®°å½•è¯¥gcæ“ä½œçš„ä¼˜å…ˆçº§ï¼Œ1è¡¨ç¤ºä¸å¯ä¸­æ–­ï¼Œ0è¡¨ç¤ºå¯ä¸­æ–­ï¼ˆè½¯é˜ˆå€¼äº§ç”Ÿçš„gcè¯·æ±‚ï¼‰$/;"	m	struct:gc_operation
process	flash.c	/^struct ssd_info *process(struct ssd_info *ssd) {$/;"	f
process_time	initialize.h	/^    int64_t process_time;          \/\/è¯¥planeèŠ±äº†å¤šå°‘æ—¶é—´åœ¨gcæ“ä½œä¸Š$/;"	m	struct:gc_info
program_count	initialize.h	/^    unsigned long program_count;$/;"	m	struct:channel_info
program_count	initialize.h	/^    unsigned long program_count;$/;"	m	struct:chip_info
program_count	initialize.h	/^    unsigned long program_count;$/;"	m	struct:ssd_info
q	Session.vim	/^inoremap <buffer> <silent> q :close$/;"	m
q	Session.vim	/^nnoremap <buffer> <silent> q :close$/;"	m
queue_length	initialize.h	/^    int queue_length;               \/\/è¯·æ±‚é˜Ÿåˆ—çš„é•¿åº¦é™åˆ¶$/;"	m	struct:parameter_value
quick_radio	initialize.h	/^    float quick_radio;$/;"	m	struct:parameter_value
read	initialize.h	/^        unsigned int read;$/;"	m	struct:gc_operation
readCnt	xmatchPro.h	/^	int readCnt;$/;"	m	struct:xmatchContext
readInput	xmatchPro.c	/^unsigned int readInput(int numBitsToRead, struct xmatchContext* decompContext)$/;"	f
read_avg	initialize.h	/^    int64_t read_avg;                    \/\/è®°å½•ç”¨äºè®¡ç®—è¯»è¯·æ±‚å¹³å‡å“åº”æ—¶é—´çš„æ—¶é—´$/;"	m	struct:ssd_info
read_count	initialize.h	/^    unsigned long read_count;           \/\/how many read count in the process of workload$/;"	m	struct:chip_info
read_count	initialize.h	/^    unsigned long read_count;$/;"	m	struct:channel_info
read_count	initialize.h	/^    unsigned long read_count;$/;"	m	struct:ssd_info
read_hit	avlTree.h	/^    unsigned long read_hit;                      \/*è¿™é‡Œçš„hitéƒ½è¡¨ç¤ºlpnçš„å‘½ä¸­æ¬¡æ•°æˆ–æ˜¯æ²¡å‘½ä¸­çš„æ¬¡æ•°*\/$/;"	m	struct:buffer_info_for_DFTL
read_hit	avlTree.h	/^    unsigned long read_hit;                      \/*è¿™é‡Œçš„hitéƒ½è¡¨ç¤ºsectorçš„å‘½ä¸­æ¬¡æ•°æˆ–æ˜¯æ²¡å‘½ä¸­çš„æ¬¡æ•°*\/$/;"	m	struct:buffer_info
read_miss_hit	avlTree.h	/^    unsigned long read_miss_hit;$/;"	m	struct:buffer_info
read_miss_hit	avlTree.h	/^    unsigned long read_miss_hit;$/;"	m	struct:buffer_info_for_DFTL
read_request_count	initialize.h	/^    unsigned int read_request_count;     \/\/è®°å½•è¯»æ“ä½œçš„æ¬¡æ•°$/;"	m	struct:ssd_info
read_test_deletion_for_subrequest	flash.c	/^void read_test_deletion_for_subrequest(struct ssd_info *ssd)$/;"	f
read_value_request_DFTL_parameters	ssd.c	/^void read_value_request_DFTL_parameters(struct ssd_info* ssd, struct request* req)$/;"	f
read_write_end	initialize.h	/^        unsigned int read_write_end;$/;"	m	struct:gc_operation
real_time_subreq	initialize.h	/^    unsigned int real_time_subreq;       \/\/è®°å½•å®æ—¶çš„å†™è¯·æ±‚ä¸ªæ•°ï¼Œç”¨åœ¨å…¨åŠ¨æ€åˆ†é…æ—¶ï¼Œchannelä¼˜å…ˆçš„æƒ…å†µ$/;"	m	struct:ssd_info
rebuildDictionary	xmatchPro.c	/^void rebuildDictionary(unsigned int orgData, int index, int matchType, DICTIONARY* dictionary)$/;"	f
related_mapping	initialize.h	/^    int related_mapping;$/;"	m	struct:parameter_value
reordering_req	ssd.c	/^int reordering_req(struct request * req )$/;"	f
repetitiveCnt	xmatchPro.h	/^	int repetitiveCnt;$/;"	m	struct:xmatchContext
request	initialize.h	/^struct request {$/;"	s
request_queue	initialize.h	/^    struct request *request_queue;       \/\/dynamic request queue$/;"	m	struct:ssd_info	typeref:struct:ssd_info::request
request_queue_length	initialize.h	/^    unsigned int request_queue_length;$/;"	m	struct:ssd_info
request_tail	initialize.h	/^    struct request *request_tail;         \/\/ the tail of the request queue$/;"	m	struct:ssd_info	typeref:struct:ssd_info::request
response_time	initialize.h	/^    int64_t response_time;$/;"	m	struct:request
restData	xmatchPro.c	/^unsigned int restData(int matchType, unsigned int newEntry)$/;"	f
right_child	avlTree.h	/^    struct _AVL_TREE_NODE *right_child;$/;"	m	struct:_AVL_TREE_NODE	typeref:struct:_AVL_TREE_NODE::_AVL_TREE_NODE
s:cpo_save	Session.vim	/^let s:cpo_save=&cpo$/;"	v
s:l	Session.vim	/^let s:l = 2 - ((0 * winheight(0) + 31) \/ 62)$/;"	v
s:l	Session.vim	/^let s:l = 341 - ((29 * winheight(0) + 31) \/ 62)$/;"	v
s:l	Session.vim	/^let s:l = 5 - ((2 * winheight(0) + 16) \/ 32)$/;"	v
s:so_save	Session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:sx	Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
scheduling_algorithm	initialize.h	/^    int scheduling_algorithm;       \/\/è®°å½•ä½¿ç”¨å“ªç§è°ƒåº¦ç®—æ³•ï¼Œ1:FCFS$/;"	m	struct:parameter_value
serviced_time	initialize.h	/^   int64_t serviced_time; $/;"	m	struct:sub_request
services_2_gc_busy_in_chip	flash.c	/^int services_2_gc_busy_in_chip(struct ssd_info *ssd)$/;"	f
services_2_r_cmd_trans_and_complete	flash.c	/^int  services_2_r_cmd_trans_and_complete(struct ssd_info *ssd) {$/;"	f
services_2_r_data_trans	flash.c	/^Status services_2_r_data_trans(struct ssd_info *ssd, unsigned int channel, unsigned int *channel_busy_flag,$/;"	f
services_2_r_wait	flash.c	/^int services_2_r_wait(struct ssd_info *ssd, unsigned int channel, unsigned int *channel_busy_flag,$/;"	f
services_2_write	flash.c	/^Status services_2_write(struct ssd_info *ssd, unsigned int channel, unsigned int *channel_busy_flag,$/;"	f
services_2_write_busy_in_chip	flash.c	/^int services_2_write_busy_in_chip(struct ssd_info *ssd)$/;"	f
set_entry_state	pagemap.c	/^int set_entry_state(struct ssd_info *ssd, unsigned int lsn, unsigned int size) {$/;"	f
should_evict_lpn_data	initialize.h	/^    struct _bi_list* should_evict_lpn_data; $/;"	m	struct:request	typeref:struct:request::_bi_list
sign_for_preemptive	initialize.h	/^        unsigned int sign_for_preemptive;$/;"	m	struct:gc_operation
simulate	ssd.c	/^struct ssd_info *simulate(struct ssd_info *ssd) {$/;"	f
size	initialize.h	/^    int size;$/;"	m	struct:sub_request
size	initialize.h	/^    unsigned int size;                 \/\/è¯·æ±‚çš„å¤§å°ï¼Œæ—¢å¤šå°‘ä¸ªæ‰‡åŒº$/;"	m	struct:request
size	ssd.c	/^unsigned int size(unsigned int stored) {$/;"	f
slack_time	initialize.h	/^   int64_t slack_time;$/;"	m	struct:sub_request
sleep_current	initialize.h	/^    float sleep_current;$/;"	m	struct:dram_parameter
small_large_write	initialize.h	/^    unsigned int small_large_write; \/\/the threshould of large write, large write do not occupt buffer, which is written back to flash directly$/;"	m	struct:parameter_value
ssd_energy	initialize.h	/^    double ssd_energy;                   \/\/SSDçš„èƒ½è€—ï¼Œæ˜¯æ—¶é—´å’ŒèŠ¯ç‰‡æ•°çš„å‡½æ•°,èƒ½è€—å› å­$/;"	m	struct:ssd_info
ssd_info	initialize.h	/^struct ssd_info {$/;"	s
ssdsim_msg	debug.h	22;"	d
ssdsim_msg	debug.h	29;"	d
state	initialize.h	/^    int state;                      \/\/åå…­è¿›åˆ¶è¡¨ç¤ºçš„è¯æ˜¯0000-FFFFï¼Œæ¯ä½è¡¨ç¤ºç›¸åº”çš„å­é¡µæ˜¯å¦æœ‰æ•ˆï¼ˆé¡µæ˜ å°„ï¼‰ã€‚æ¯”å¦‚åœ¨è¿™ä¸ªé¡µä¸­ï¼Œ0ï¼Œ1å·å­é¡µæœ‰æ•ˆï¼Œ2ï¼Œ3æ— æ•ˆï¼Œè¿™ä¸ªåº”è¯¥æ˜¯0x0003. lxc é¡ºåºä¸ºï¼š3210é¡ºåºï¼Œä¸”æœ‰æ•ˆä¸º1ï¼Œè€Œä¸”æ­¤å¤„å¯ä»¥æœ‰è‡³å°‘32ä¸ªå­é¡µã€‚ã€‚$/;"	m	struct:entry
state	initialize.h	/^    unsigned int state;              \/\/ä½¿ç”¨stateçš„æœ€é«˜ä½è¡¨ç¤ºè¯¥å­è¯·æ±‚æ˜¯å¦æ˜¯ä¸€å¯¹å¤šæ˜ å°„å…³ç³»ä¸­çš„ä¸€ä¸ªï¼Œæ˜¯çš„è¯ï¼Œéœ€è¦è¯»åˆ°bufferä¸­ã€‚1è¡¨ç¤ºæ˜¯ä¸€å¯¹å¤šï¼Œ0è¡¨ç¤ºä¸ç”¨å†™åˆ°buffer$/;"	m	struct:sub_request
state	initialize.h	/^    unsigned int state;           \/\/è®°å½•å½“å‰gcè¯·æ±‚çš„çŠ¶æ€$/;"	m	struct:gc_operation
state	initialize.h	/^    unsigned int state;$/;"	m	struct:Dram_write_map
static_allocation	initialize.h	/^    int static_allocation;          \/\/è®°å½•æ˜¯é‚£ç§é™æ€åˆ†é…æ–¹å¼ï¼Œå¦‚ICS09é‚£ç¯‡æ–‡ç« æ‰€è¿°çš„æ‰€æœ‰é™æ€åˆ†é…æ–¹å¼$/;"	m	struct:parameter_value
static_write	flash.c	/^static_write(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, struct sub_request *sub) {$/;"	f
statistic_output	ssd.c	/^void statistic_output(struct ssd_info *ssd) {$/;"	f
statistic_write_request_number	ssd.c	/^int  statistic_write_request_number(struct ssd_info *ssd)$/;"	f
statisticfile	initialize.h	/^    FILE *statisticfile;$/;"	m	struct:ssd_info
statisticfile2	initialize.h	/^    FILE *statisticfile2;$/;"	m	struct:ssd_info
statisticfilename	initialize.h	/^    char statisticfilename[30];$/;"	m	struct:ssd_info
statisticfilename2	initialize.h	/^    char statisticfilename2[30];$/;"	m	struct:ssd_info
status	initialize.h	/^char status;$/;"	m	struct:__anon2
status	initialize.h	/^dir_stat status;$/;"	m	struct:__anon3
stored	initialize.h	/^    unsigned char* stored;                \/\/indicate the real translation page $/;"	m	struct:buffer_group_for_DFTL
stored	initialize.h	/^    unsigned int stored;                \/\/indicate the sector is stored in buffer or not. 1 indicates the sector is stored and 0 indicate the sector isn't stored.EX.  00110011 indicates the first, second, fifth, sixth sector is stored in buffer.$/;"	m	struct:buffer_group
storedsub	initialize.h	/^struct sub_request *storedsub;          \/\/suspended write sub value$/;"	m	struct:chip_info	typeref:struct:chip_info::sub_request
striping	initialize.h	/^    int striping;                   \/\/è¡¨ç¤ºæ˜¯å¦ä½¿ç”¨äº†stripingæ–¹å¼ï¼Œ0è¡¨ç¤ºæ²¡æœ‰ï¼Œ1è¡¨ç¤ºæœ‰$/;"	m	struct:parameter_value
sub_page	initialize.h	/^    unsigned int sub_page;$/;"	m	struct:local
sub_request	initialize.h	/^struct sub_request {$/;"	s
subpage_capacity	initialize.h	/^    unsigned int subpage_capacity;$/;"	m	struct:parameter_value
subpage_num_page	initialize.h	/^    unsigned int subpage_num_page;      \/\/indicate how many subpage in a page$/;"	m	struct:chip_info
subpage_page	initialize.h	/^    unsigned int subpage_page;$/;"	m	struct:parameter_value
subs	initialize.h	/^    struct sub_request *subs;          \/\/é“¾æ¥åˆ°å±äºè¯¥è¯·æ±‚çš„æ‰€æœ‰å­è¯·æ±‚ \/\/ we put all subrequests here, containing mappingtable relevant subrequests.$/;"	m	struct:request	typeref:struct:request::sub_request
subs_r_head	initialize.h	/^    struct sub_request *subs_r_head;     \/\/channelä¸Šçš„è¯»è¯·æ±‚é˜Ÿåˆ—å¤´ï¼Œå…ˆæœåŠ¡å¤„äºé˜Ÿåˆ—å¤´çš„å­è¯·æ±‚$/;"	m	struct:channel_info	typeref:struct:channel_info::sub_request
subs_r_tail	initialize.h	/^    struct sub_request *subs_r_tail;     \/\/channelä¸Šçš„è¯»è¯·æ±‚é˜Ÿåˆ—å°¾ï¼Œæ–°åŠ è¿›æ¥çš„å­è¯·æ±‚åŠ åˆ°é˜Ÿå°¾$/;"	m	struct:channel_info	typeref:struct:channel_info::sub_request
subs_w_head	initialize.h	/^    struct sub_request *subs_w_head;     \/\/channelä¸Šçš„å†™è¯·æ±‚é˜Ÿåˆ—å¤´ï¼Œå…ˆæœåŠ¡å¤„äºé˜Ÿåˆ—å¤´çš„å­è¯·æ±‚$/;"	m	struct:channel_info	typeref:struct:channel_info::sub_request
subs_w_head	initialize.h	/^    struct sub_request *subs_w_head;     \/\/å½“é‡‡ç”¨å…¨åŠ¨æ€åˆ†é…æ—¶ï¼Œåˆ†é…æ˜¯ä¸çŸ¥é“åº”è¯¥æŒ‚è½½å“ªä¸ªchannelä¸Šï¼Œæ‰€ä»¥å…ˆæŒ‚åœ¨ssdä¸Šï¼Œç­‰è¿›å…¥processå‡½æ•°æ—¶æ‰æŒ‚åˆ°ç›¸åº”çš„channelçš„è¯»è¯·æ±‚é˜Ÿåˆ—ä¸Š$/;"	m	struct:ssd_info	typeref:struct:ssd_info::sub_request
subs_w_tail	initialize.h	/^    struct sub_request *subs_w_tail;     \/\/channelä¸Šçš„å†™è¯·æ±‚é˜Ÿåˆ—ï¼Œæ–°åŠ è¿›æ¥çš„å­è¯·æ±‚åŠ åˆ°é˜Ÿå°¾$/;"	m	struct:channel_info	typeref:struct:channel_info::sub_request
subs_w_tail	initialize.h	/^    struct sub_request *subs_w_tail;$/;"	m	struct:ssd_info	typeref:struct:ssd_info::sub_request
supply_voltage	initialize.h	/^    double supply_voltage;$/;"	m	struct:parameter_value
tADL	initialize.h	/^    int tADL;      \/\/address to data loading time$/;"	m	struct:ac_time_characteristics
tALH	initialize.h	/^    int tALH;      \/\/ALE hold time$/;"	m	struct:ac_time_characteristics
tALS	initialize.h	/^    int tALS;      \/\/ALE setup time$/;"	m	struct:ac_time_characteristics
tAR	initialize.h	/^    int tAR;       \/\/ALE to RE delay$/;"	m	struct:ac_time_characteristics
tAVLTree	avlTree.h	/^} tAVLTree;$/;"	t	typeref:struct:buffer_info
tAVLTree_for_DFTL	avlTree.h	/^} tAVLTree_for_DFTL;$/;"	t	typeref:struct:buffer_info_for_DFTL
tBERS	initialize.h	/^    int tBERS;     \/\/block erase time$/;"	m	struct:ac_time_characteristics
tCEA	initialize.h	/^    int tCEA;      \/\/CE access time$/;"	m	struct:ac_time_characteristics
tCH	initialize.h	/^    int tCH;       \/\/CE hold time$/;"	m	struct:ac_time_characteristics
tCHZ	initialize.h	/^    int tCHZ;      \/\/CE high to output hi-z$/;"	m	struct:ac_time_characteristics
tCLH	initialize.h	/^    int tCLH;      \/\/CLE hold time$/;"	m	struct:ac_time_characteristics
tCLR	initialize.h	/^    int tCLR;      \/\/CLE to RE delay$/;"	m	struct:ac_time_characteristics
tCLS	initialize.h	/^    int tCLS;      \/\/CLE setup time$/;"	m	struct:ac_time_characteristics
tCOH	initialize.h	/^    int tCOH;      \/\/CE high to output hold$/;"	m	struct:ac_time_characteristics
tCS	initialize.h	/^    int tCS;       \/\/CE setup time$/;"	m	struct:ac_time_characteristics
tDBSY	initialize.h	/^    int tDBSY;     \/\/bummy busy time for two-plane program$/;"	m	struct:ac_time_characteristics
tDH	initialize.h	/^    int tDH;       \/\/data hold time$/;"	m	struct:ac_time_characteristics
tDS	initialize.h	/^    int tDS;       \/\/data setup time$/;"	m	struct:ac_time_characteristics
tIR	initialize.h	/^    int tIR;       \/\/output hi-z to RE low$/;"	m	struct:ac_time_characteristics
tPROG	initialize.h	/^    int tPROG;     \/\/program time   coarse partical size$/;"	m	struct:ac_time_characteristics
tPROG_Nw_cycle	initialize.h	/^    int tPROG_Nw_cycle;     \/\/ ISPP iterations number. Here is 5$/;"	m	struct:ac_time_characteristics
tPROG_Tw_cycle	initialize.h	/^    int tPROG_Tw_cycle;     \/\/ one iterations consisting of tPROG_w_program + tPROG_w_verify (32+8)us. $/;"	m	struct:ac_time_characteristics
tPROG_buffer	initialize.h	/^    int tPROG_buffer;       \/\/ the time taken to load the page buffer with data.$/;"	m	struct:ac_time_characteristics
tPROG_r_phy	initialize.h	/^    int tPROG_r_phy;        \/\/ here is normal read + read_extra in suspension.but this design will not use average value for we can $/;"	m	struct:ac_time_characteristics
tPROG_w_progam	initialize.h	/^    int tPROG_w_progam;     \/\/ the flash program time in one iterations $/;"	m	struct:ac_time_characteristics
tPROG_w_total	initialize.h	/^    int tPROG_w_total;      \/\/ Total program time\/Nw_cycle. Here is 40us$/;"	m	struct:ac_time_characteristics
tPROG_w_verify	initialize.h	/^    int tPROG_w_verify;     \/\/ verify the program result in flash. acturally it is the same to tERSE_verify $/;"	m	struct:ac_time_characteristics
tR	initialize.h	/^    int tR;        \/\/data transfer from cell to register$/;"	m	struct:ac_time_characteristics
tRC	initialize.h	/^    int tRC;       \/\/read cycle time$/;"	m	struct:ac_time_characteristics
tREA	initialize.h	/^    int tREA;      \/\/RE access time$/;"	m	struct:ac_time_characteristics
tREH	initialize.h	/^    int tREH;      \/\/RE high to output time$/;"	m	struct:ac_time_characteristics
tRHOH	initialize.h	/^    int tRHOH;     \/\/RE high to output hold$/;"	m	struct:ac_time_characteristics
tRHW	initialize.h	/^    int tRHW;      \/\/RE high to WE low$/;"	m	struct:ac_time_characteristics
tRHZ	initialize.h	/^    int tRHZ;      \/\/RE high to output hi-z$/;"	m	struct:ac_time_characteristics
tRLOH	initialize.h	/^    int tRLOH;     \/\/RE low to output hold$/;"	m	struct:ac_time_characteristics
tRP	initialize.h	/^    int tRP;       \/\/RE pulse width$/;"	m	struct:ac_time_characteristics
tRR	initialize.h	/^    int tRR;       \/\/ready to RE low$/;"	m	struct:ac_time_characteristics
tRST	initialize.h	/^    int tRST;      \/\/device resetting time$/;"	m	struct:ac_time_characteristics
tWB	initialize.h	/^    int tWB;       \/\/WE high to busy$/;"	m	struct:ac_time_characteristics
tWC	initialize.h	/^    int tWC;       \/\/write cycle time$/;"	m	struct:ac_time_characteristics
tWH	initialize.h	/^    int tWH;       \/\/WE high hold time$/;"	m	struct:ac_time_characteristics
tWHR	initialize.h	/^    int tWHR;      \/\/WE high to RE low$/;"	m	struct:ac_time_characteristics
tWP	initialize.h	/^    int tWP;       \/\/WE pulse width$/;"	m	struct:ac_time_characteristics
tail	js_list.h	/^	struct nodeJSList* tail;$/;"	m	struct:jsList	typeref:struct:jsList::nodeJSList
temp_lba	initialize.h	/^int64_t temp_lba;$/;"	m	struct:ssd_info
test_finish_deletion	ssd.c	/^void test_finish_deletion(struct ssd_info* ssd)$/;"	f
the_number_of_evicting_from_uncom_to_com	initialize.h	/^    int the_number_of_evicting_from_uncom_to_com; \/\/0 means no pages, other number means the real page numbers.$/;"	m	struct:request
this_node_content_size	initialize.h	/^    unsigned int this_node_content_size;\/\/indicate the translation page size in this node; $/;"	m	struct:buffer_group_for_DFTL
threshold_fixed_adjust	initialize.h	/^    int threshold_fixed_adjust;$/;"	m	struct:parameter_value
threshold_value	initialize.h	/^    int threshold_value;$/;"	m	struct:parameter_value
time	initialize.h	/^    int64_t time;                      \/\/è¯·æ±‚åˆ°è¾¾çš„æ—¶é—´ï¼Œå•ä½ä¸ºus,è¿™é‡Œå’Œé€šå¸¸çš„ä¹ æƒ¯ä¸ä¸€æ ·ï¼Œé€šå¸¸çš„æ˜¯msä¸ºå•ä½ï¼Œè¿™é‡Œéœ€è¦æœ‰ä¸ªå•ä½å˜æ¢è¿‡ç¨‹$/;"	m	struct:request
time_characteristics	initialize.h	/^    struct ac_time_characteristics time_characteristics;$/;"	m	struct:parameter_value	typeref:struct:parameter_value::ac_time_characteristics
time_step	initialize.h	/^    unsigned int time_step;$/;"	m	struct:parameter_value
token	initialize.h	/^    unsigned int token;                  \/\/åœ¨åŠ¨æ€åˆ†é…ä¸­ï¼Œä¸ºé˜²æ­¢æ¯æ¬¡åˆ†é…åœ¨ç¬¬ä¸€ä¸ªchanneléœ€è¦ç»´æŒä¸€ä¸ªä»¤ç‰Œï¼Œæ¯æ¬¡ä»ä»¤ç‰Œæ‰€æŒ‡çš„ä½ç½®å¼€å§‹åˆ†é…$/;"	m	struct:ssd_info
token	initialize.h	/^    unsigned int token;                  \/\/åœ¨åŠ¨æ€åˆ†é…ä¸­ï¼Œä¸ºé˜²æ­¢æ¯æ¬¡åˆ†é…åœ¨ç¬¬ä¸€ä¸ªchipéœ€è¦ç»´æŒä¸€ä¸ªä»¤ç‰Œï¼Œæ¯æ¬¡ä»ä»¤ç‰Œæ‰€æŒ‡çš„ä½ç½®å¼€å§‹åˆ†é…$/;"	m	struct:channel_info
token	initialize.h	/^    unsigned int token;                 \/\/åœ¨åŠ¨æ€åˆ†é…ä¸­ï¼Œä¸ºé˜²æ­¢æ¯æ¬¡åˆ†é…åœ¨ç¬¬ä¸€ä¸ªdieéœ€è¦ç»´æŒä¸€ä¸ªä»¤ç‰Œï¼Œæ¯æ¬¡ä»ä»¤ç‰Œæ‰€æŒ‡çš„ä½ç½®å¼€å§‹åˆ†é…$/;"	m	struct:chip_info
token	initialize.h	/^    unsigned int token;                 \/\/åœ¨åŠ¨æ€åˆ†é…ä¸­ï¼Œä¸ºé˜²æ­¢æ¯æ¬¡åˆ†é…åœ¨ç¬¬ä¸€ä¸ªplaneéœ€è¦ç»´æŒä¸€ä¸ªä»¤ç‰Œï¼Œæ¯æ¬¡ä»ä»¤ç‰Œæ‰€æŒ‡çš„ä½ç½®å¼€å§‹åˆ†é…$/;"	m	struct:die_info
total_wait_evict	initialize.h	/^    unsigned int total_wait_evict; \/\/ 1 means needing wait, 0 do not have to wait or finishing evicting.$/;"	m	struct:request
total_wait_fetch_mappingtable	initialize.h	/^    unsigned int total_wait_fetch_mappingtable; \/\/ 1 means needing fetching, 0 dont have to fetch or finish fetching$/;"	m	struct:request
traceCompTranslationbuffer_msg	debug.h	107;"	d
traceCompTranslationbuffer_msg	debug.h	114;"	d
traceEntrybuffer_msg	debug.h	75;"	d
traceEntrybuffer_msg	debug.h	82;"	d
traceError_msg	debug.h	37;"	d
traceError_msg	debug.h	44;"	d
traceRead_msg	debug.h	50;"	d
traceRead_msg	debug.h	57;"	d
traceTranslationbuffer_msg	debug.h	91;"	d
traceTranslationbuffer_msg	debug.h	98;"	d
traceWrite_msg	debug.h	62;"	d
traceWrite_msg	debug.h	69;"	d
trace_assert	pagemap.c	/^void trace_assert(int64_t time_t, int device, unsigned int lsn, int size, int ope)\/\/æ–­è¨€$/;"	f
trace_output	ssd.c	/^void trace_output(struct ssd_info *ssd) {$/;"	f
tracefile	initialize.h	/^    FILE *tracefile;$/;"	m	struct:ssd_info
tracefilename	initialize.h	/^    char tracefilename[30];$/;"	m	struct:ssd_info
transfer_size	ssd.c	/^unsigned int transfer_size(struct ssd_info *ssd, int need_distribute, unsigned int lpn, struct request *req) {$/;"	f
tree_root	avlTree.h	/^    struct _AVL_TREE_NODE *tree_root;$/;"	m	struct:_AVL_TREE_NODE	typeref:struct:_AVL_TREE_NODE::_AVL_TREE_NODE
try_to_restore_gc_function	flash.c	/^int try_to_restore_gc_function(struct ssd_info *ssd, struct gc_operation *gc_node, unsigned int channel, unsigned int chip)$/;"	f
try_to_restore_write_function	flash.c	/^int try_to_restore_write_function(struct ssd_info *ssd){$/;"	f
type	initialize.h	/^    int type;                        \/\/è®°å½•è¯¥äº‹ä»¶çš„ç±»å‹ï¼Œ1è¡¨ç¤ºå‘½ä»¤ç±»å‹ï¼Œ2è¡¨ç¤ºæ•°æ®ä¼ è¾“ç±»å‹$/;"	m	struct:event_node
un_greed_copyback	flash.c	/^struct ssd_info *un_greed_copyback(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die,$/;"	f
un_greed_interleave_copyback	flash.c	/^un_greed_interleave_copyback(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die,$/;"	f
uncompression_max_cached_dir_slots_sizein_byte	initialize.h	/^unsigned long uncompression_max_cached_dir_slots_sizein_byte;\/\/$/;"	m	struct:__anon4
uncompression_now_cached_dir_slots_sizein_byte	initialize.h	/^unsigned long uncompression_now_cached_dir_slots_sizein_byte;\/\/$/;"	m	struct:__anon4
uninterrupt_gc	pagemap.c	/^uninterrupt_gc(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane) {$/;"	f
update	initialize.h	/^    struct sub_request *update;       \/\/å› ä¸ºåœ¨å†™æ“ä½œä¸­å­˜åœ¨æ›´æ–°æ“ä½œï¼Œå› ä¸ºåœ¨åŠ¨æ€åˆ†é…æ–¹å¼ä¸­æ— æ³•ä½¿ç”¨copybackæ“ä½œï¼Œéœ€è¦å°†åŸæ¥çš„é¡µè¯»å‡ºåæ‰èƒ½è¿›è¡Œå†™æ“ä½œï¼Œæ‰€ä»¥ï¼Œå°†å› æ›´æ–°äº§ç”Ÿçš„è¯»æ“ä½œæŒ‚åœ¨è¿™ä¸ªæŒ‡é’ˆä¸Š$/;"	m	struct:sub_request	typeref:struct:sub_request::sub_request
updateDictionary	xmatchPro.c	/^int updateDictionary(	unsigned int input, $/;"	f
update_read_count	initialize.h	/^    unsigned int update_read_count;      \/\/è®°å½•å› ä¸ºæ›´æ–°æ“ä½œå¯¼è‡´çš„é¢å¤–è¯»å‡ºæ“ä½œ$/;"	m	struct:ssd_info
validByte	xmatchPro.c	/^int validByte[16][4] = {$/;"	v
valid_state	initialize.h	/^    int valid_state;                   \/\/indicate the page is valid or invalid$/;"	m	struct:page_info
value	js_list.h	/^	TYPE value;$/;"	m	struct:nodeJSList
value_request_DFTL_parameters_for_distribute_subrequests	ssd.c	/^ struct ssd_info* value_request_DFTL_parameters_for_distribute_subrequests(struct ssd_info* ssd)$/;"	f
victim_block_freepage_statistic	initialize.h	/^        unsigned int victim_block_freepage_statistic;$/;"	m	struct:gc_operation
victim_block_number	initialize.h	/^        unsigned int victim_block_number;$/;"	m	struct:gc_operation
voltage	initialize.h	/^    float voltage;$/;"	m	struct:dram_parameter
wait_evict_sign	initialize.h	/^   unsigned int wait_evict_sign; \/\/ 1 means needing wait, 0 do not have to wait or finishing evicting.$/;"	m	struct:sub_request
wait_evict_sign_finished	initialize.h	/^unsigned int wait_evict_sign_finished; \/\/ 1 means finished$/;"	m	struct:sub_request
wait_fetch_mappingtable_sign	initialize.h	/^   unsigned int wait_fetch_mappingtable_sign; \/\/ 1 means needing fetching, 0 dont have to fetch or finish fetching$/;"	m	struct:sub_request
wait_fetch_mappingtable_sign_finished	initialize.h	/^unsigned int wait_fetch_mappingtable_sign_finished; \/\/ 1 means finished$/;"	m	struct:sub_request
waste_page_count	initialize.h	/^    unsigned long waste_page_count;      \/\/è®°å½•å› ä¸ºé«˜çº§å‘½ä»¤çš„é™åˆ¶å¯¼è‡´çš„é¡µæµªè´¹$/;"	m	struct:ssd_info
wear_leveling	initialize.h	/^    int wear_leveling;              \/\/ WLç®—æ³•$/;"	m	struct:parameter_value
write	initialize.h	/^        unsigned int write;$/;"	m	struct:gc_operation
writeCnt	xmatchPro.h	/^	int writeCnt;$/;"	m	struct:xmatchContext
writeToOutput	xmatchPro.c	/^void writeToOutput(	int numValidBitInData, $/;"	f
write_avg	initialize.h	/^    int64_t write_avg;                   \/\/è®°å½•ç”¨äºè®¡ç®—å†™è¯·æ±‚å¹³å‡å“åº”æ—¶é—´çš„æ—¶é—´$/;"	m	struct:ssd_info
write_flash_count	initialize.h	/^    unsigned long write_flash_count;     \/\/å®é™…äº§ç”Ÿçš„å¯¹flashçš„å†™æ“ä½œ$/;"	m	struct:ssd_info
write_hit	avlTree.h	/^    unsigned long write_hit;$/;"	m	struct:buffer_info
write_hit	avlTree.h	/^    unsigned long write_hit;$/;"	m	struct:buffer_info_for_DFTL
write_miss_hit	avlTree.h	/^    unsigned long write_miss_hit;$/;"	m	struct:buffer_info
write_miss_hit	avlTree.h	/^    unsigned long write_miss_hit;$/;"	m	struct:buffer_info_for_DFTL
write_page	flash.c	/^Status write_page(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane,$/;"	f
write_preemptive_sign	initialize.h	/^int write_preemptive_sign; \/\/ 1 means the preemptive process sign.$/;"	m	struct:chip_info
write_request_count	initialize.h	/^    unsigned int write_request_count;    \/\/è®°å½•å†™æ“ä½œçš„æ¬¡æ•°$/;"	m	struct:ssd_info
write_request_get_missing_in_databuffer	ssd.c	/^struct ssd_info* write_request_get_missing_in_databuffer(struct ssd_info* ssd, unsigned int lpn, int state, struct request* req)$/;"	f
write_suspend_doing	initialize.h	/^unsigned int write_suspend_doing;$/;"	m	struct:ssd_info
write_suspend_times	initialize.h	/^unsigned int write_suspend_times;\/\/ statistic for write suspend times.$/;"	m	struct:ssd_info
write_test_deletion_for_subrequest	flash.c	/^void write_test_deletion_for_subrequest(struct ssd_info *ssd)$/;"	f
write_value_request_DFTL_parameters	ssd.c	/^void write_value_request_DFTL_parameters(struct ssd_info* ssd, struct request* req)$/;"	f
written_count	initialize.h	/^    unsigned int written_count;        \/\/è®°å½•è¯¥é¡µè¢«å†™çš„æ¬¡æ•°$/;"	m	struct:page_info
xmatchCompress	xmatchPro.c	/^int xmatchCompress(unsigned char* input, int size, unsigned char* output)$/;"	f
xmatchContext	xmatchPro.h	/^struct xmatchContext$/;"	s
xmatchDecode	xmatchPro.c	/^int xmatchDecode(struct xmatchContext* decompContext, int orgSize)$/;"	f
xmatchDecompress	xmatchPro.c	/^int xmatchDecompress(unsigned char* input, int size, unsigned char* output)$/;"	f
xmatchEncode	xmatchPro.c	/^int xmatchEncode(struct xmatchContext* compContext)$/;"	f
zt	Session.vim	/^normal! zt$/;"	m
